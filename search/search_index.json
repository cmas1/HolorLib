{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"","title":"Home"},{"location":"about/index.html","text":"About HolorLib \u00b6 HolorLib is a C++ library that implements generic multidimensional containers of objects. These objects may be standard types, such as floats , ints or vector<double> , or user defined types such as a struct . We call this containers Holor and HolorRef . HolorLib provides fundamental operations to manipulate and access these containers, such as indexing and slicing. However, this is not a mathematical library : operations to manipulate the containers and their content, such as addition or product, are typically application specific and are not implemented in this library interface. It is left to the users, depending on their use-case, to extend the HolorLib interface as needed. Next steps: Origin of the word Holor What's a Holor container?","title":"About HolorLib"},{"location":"about/index.html#about-holorlib","text":"HolorLib is a C++ library that implements generic multidimensional containers of objects. These objects may be standard types, such as floats , ints or vector<double> , or user defined types such as a struct . We call this containers Holor and HolorRef . HolorLib provides fundamental operations to manipulate and access these containers, such as indexing and slicing. However, this is not a mathematical library : operations to manipulate the containers and their content, such as addition or product, are typically application specific and are not implemented in this library interface. It is left to the users, depending on their use-case, to extend the HolorLib interface as needed. Next steps: Origin of the word Holor What's a Holor container?","title":"About HolorLib"},{"location":"about/holor_containers.html","text":"What's a Holor container? \u00b6 Holor containers are generic multi-dimensional collections of homogeneous elements, i.e., all elements must be of the same type. These containers are characterized by: the number of dimensions N ; the lengths , that is the number of elements along each individual dimension; the type of the elements stored. From the point of view of implementation, holor containers have three fundamental components: Memory : a holor container has access to a contiguous area of memory where the \"contained\" elements are stored. Layout : each holor container possesses a Layout , an object that contains the information to map from the the multi-dimensional coordinates (indices) in the container dimensions to a memory location, and viceversa. In particular, holor containers use a row-major ordering . Indexing/Slicing operations : a holor container is endowed with a set of operations that allow to access its individual elements from a set of N coordinates ( indexing ), or to extract a holor container that is a subset of the original one ( slicing ) The implementation of Holor containers has three fundamental components: a contiguous memory location that stores the elements, a layout that contains information about the correspondance between the coordinates of the elements and their memory location, and a set of operations to access or slice the container. Memory \u00b6 Each holor container has access to a contiguous area of memory where its elements are stored. The library provides two different types of containers, which differentiate from each other for the ownership of the storage: A Holor is a container that has ownership of the memory where the elements are stored. This is implemented as an std::array within the container. A HolorRef is a non-owning Holor-like view over a sequence of elements stored in a contiguous area of memory. This is implemented as a pointer to the memory location. Layout \u00b6 A Layout contains the essential information needed to map the indices of the holor container to a location in the memory where the elements are stored. Offset : the displacement in the contiguous memory of the first element indexed by the layout from the beginning of the memory. Lengths : the numbers of elements along every dimension of the layout. Strides : the distances in the 1D memory sequence between successive elements in individual dimensions of the layout. Important For a Layout with N dimensions, both lengths and strides must have size N . For a generic N dimensional holor container, the total number of elements stored is \\begin{equation} size = \\prod_{i=0}^{N-1} lengths[i] \\end{equation} The index of the memory location corresponding to the element of the container with coordinates \\((c_0, \\ldots, c_{N-1})\\) is \\begin{equation} index = offset + \\sum_{i=0}^{N-1} c_i \\cdot strides[i] \\end{equation} Indexing and Slicing operations \u00b6 Holor containers are endowed with operations that allow to index individual elements of the container, accessing the memory location where they are stored, or to slice parts of it yielding a new view (i.e., a HolorRef) over the selected part of the container. The indexing and slicing operations have a simple sintax common to many scripting languages. For example, one can write using namespace holor ; Holor < int , 2 > A = {{ 1 , 2 , 3 , 4 },{ 5 , 6 , 7 , 8 },{ 9 , 10 , 11 , 12 }}; // 3-by-4 matrix of integers auto c = A ( 2 , 3 ); // indexing a single element. c has the value 8. auto B = A ( range ( 0 , 1 ), range ( 2 , 3 )); // Slicing a 2-by-2 matrix. B is a HolorRef that views the elements {{3,4}, {7,8}} of A For more detailed examples refer to the section Tutorials. Example: indexing \u00b6 Consider a \\(2 \\times 3 \\times 4\\) Holor as in figure. Indexing example The container has 24 elements which are stored contiguously. The Holor's Layout has: offset = 0; lengths = [2, 3, 4]; strides = [12, 4, 1]; The element with coordinates (0,0,0) is located ath the position \\(0 + 0 \\cdot 12 + 0 \\cdot 4 + 0 \\cdot 1 = 0\\) of the memory, whereas the element with coordinates (0,2,2) is located in the memory area at the position \\(0 + 0 \\cdot 12 + 2 \\cdot 4 + 2 \\cdot 1 = 10\\) . Example: slicing \u00b6 Consider the same \\(2 \\times 3 \\times 4\\) Holor as in the previous example, and suppose that we want to take a 2-by-2 slice corresponding to the first row, last two columns and first two lines in the third dimension. In code, this would be auto B = A ( 1 , range ( 0 , 1 ), range ( 0 , 1 )); //suppose that A is the name of the Holor to be sliced Slicing example The slicing operation extracts a subset of the Holor container. The slicing operation does not create a new Holor, rather it returns a HolorRef that provides a view over the selected slice. For this purpose, a new Layout that describes the location of the selected elements in the original contiguous memory is computed. In this example, the Layout corresponding to the selected 2-by-2 slice is: offset = 4 lengths = [2, 2] strides = [4, 1]","title":"What's a Holor container"},{"location":"about/holor_containers.html#whats-a-holor-container","text":"Holor containers are generic multi-dimensional collections of homogeneous elements, i.e., all elements must be of the same type. These containers are characterized by: the number of dimensions N ; the lengths , that is the number of elements along each individual dimension; the type of the elements stored. From the point of view of implementation, holor containers have three fundamental components: Memory : a holor container has access to a contiguous area of memory where the \"contained\" elements are stored. Layout : each holor container possesses a Layout , an object that contains the information to map from the the multi-dimensional coordinates (indices) in the container dimensions to a memory location, and viceversa. In particular, holor containers use a row-major ordering . Indexing/Slicing operations : a holor container is endowed with a set of operations that allow to access its individual elements from a set of N coordinates ( indexing ), or to extract a holor container that is a subset of the original one ( slicing ) The implementation of Holor containers has three fundamental components: a contiguous memory location that stores the elements, a layout that contains information about the correspondance between the coordinates of the elements and their memory location, and a set of operations to access or slice the container.","title":"What's a Holor container?"},{"location":"about/holor_containers.html#memory","text":"Each holor container has access to a contiguous area of memory where its elements are stored. The library provides two different types of containers, which differentiate from each other for the ownership of the storage: A Holor is a container that has ownership of the memory where the elements are stored. This is implemented as an std::array within the container. A HolorRef is a non-owning Holor-like view over a sequence of elements stored in a contiguous area of memory. This is implemented as a pointer to the memory location.","title":"Memory"},{"location":"about/holor_containers.html#layout","text":"A Layout contains the essential information needed to map the indices of the holor container to a location in the memory where the elements are stored. Offset : the displacement in the contiguous memory of the first element indexed by the layout from the beginning of the memory. Lengths : the numbers of elements along every dimension of the layout. Strides : the distances in the 1D memory sequence between successive elements in individual dimensions of the layout. Important For a Layout with N dimensions, both lengths and strides must have size N . For a generic N dimensional holor container, the total number of elements stored is \\begin{equation} size = \\prod_{i=0}^{N-1} lengths[i] \\end{equation} The index of the memory location corresponding to the element of the container with coordinates \\((c_0, \\ldots, c_{N-1})\\) is \\begin{equation} index = offset + \\sum_{i=0}^{N-1} c_i \\cdot strides[i] \\end{equation}","title":"Layout"},{"location":"about/holor_containers.html#indexing-and-slicing-operations","text":"Holor containers are endowed with operations that allow to index individual elements of the container, accessing the memory location where they are stored, or to slice parts of it yielding a new view (i.e., a HolorRef) over the selected part of the container. The indexing and slicing operations have a simple sintax common to many scripting languages. For example, one can write using namespace holor ; Holor < int , 2 > A = {{ 1 , 2 , 3 , 4 },{ 5 , 6 , 7 , 8 },{ 9 , 10 , 11 , 12 }}; // 3-by-4 matrix of integers auto c = A ( 2 , 3 ); // indexing a single element. c has the value 8. auto B = A ( range ( 0 , 1 ), range ( 2 , 3 )); // Slicing a 2-by-2 matrix. B is a HolorRef that views the elements {{3,4}, {7,8}} of A For more detailed examples refer to the section Tutorials.","title":"Indexing and Slicing operations"},{"location":"about/holor_containers.html#example-indexing","text":"Consider a \\(2 \\times 3 \\times 4\\) Holor as in figure. Indexing example The container has 24 elements which are stored contiguously. The Holor's Layout has: offset = 0; lengths = [2, 3, 4]; strides = [12, 4, 1]; The element with coordinates (0,0,0) is located ath the position \\(0 + 0 \\cdot 12 + 0 \\cdot 4 + 0 \\cdot 1 = 0\\) of the memory, whereas the element with coordinates (0,2,2) is located in the memory area at the position \\(0 + 0 \\cdot 12 + 2 \\cdot 4 + 2 \\cdot 1 = 10\\) .","title":"Example: indexing"},{"location":"about/holor_containers.html#example-slicing","text":"Consider the same \\(2 \\times 3 \\times 4\\) Holor as in the previous example, and suppose that we want to take a 2-by-2 slice corresponding to the first row, last two columns and first two lines in the third dimension. In code, this would be auto B = A ( 1 , range ( 0 , 1 ), range ( 0 , 1 )); //suppose that A is the name of the Holor to be sliced Slicing example The slicing operation extracts a subset of the Holor container. The slicing operation does not create a new Holor, rather it returns a HolorRef that provides a view over the selected slice. For this purpose, a new Layout that describes the location of the selected elements in the original contiguous memory is computed. In this example, the Layout corresponding to the selected 2-by-2 slice is: offset = 4 lengths = [2, 2] strides = [4, 1]","title":"Example: slicing"},{"location":"about/origin_of_holor.html","text":"Origin of the word Holor \u00b6 The name of the library pays homage to the work of Parry Moon and Domina Eberle Spencer, who coined the term Holor : The word holor indicates a mathematical entity that is made up of one or more independent quantities. Examples of holors are complex numbers, vectors, matrices, tensors, and other hypernumbers. -- Parry Moon and Domina Eberle Spencer 1 Moon and Spencer define holors (from the Greek \u1f45\u03bb\u03bf\u03c2 , a whole) as collections of indipendent elements, or merates (from the Greek \u03bc\u03ad\u03c1\u03bf\u03c2 , a part). In their definition, holors are characterized by two fundamental qualities: valence \\(N\\) : which indicates the number of dimensions . plethos \\(n_i\\) : which indicates the number of elements in the \\(i\\) -th dimension. Moon and Spencer also introduce a general index notation to identify the merates of a holor: a single dimensional holor with three merates is denoted as \\(v^i = (v^1, v^2, v^3)\\) , a bi-dimensional holor with \\(2 \\times 2\\) elements is denoted as \\(A^{ij} = (A^{1,1}, A^{1,2}, A^{2,1}, A^{2,2})\\) , and so on. The definition of holors is purposedly broad so as to encompass under a unique formulation a large number of mathematical entities, such as matrices, tensors, complex numbers, quaternions, etcetera. Figure 1 illustrates some examples of holors. Figure 1 : Some examples of holors: a) a 3D matrix; b) a complex number; c) a quaternion. The Theory of Holors goes further to elaborate an algebra of holors, an operation called \\(\\gamma\\) -product that allows to modify the characteristics (valence, positions of indices, symmetry or antisymmetry) of holors, transformations. It also provides definitions for notable classes of holors, like tensors, akinetors, oudors. Parry Moon and Domina Eberle Spencer, Theory of Holors: a generalization of tensors , Cambridge, England: Cambridge University Press, 1986 \u21a9","title":"Origin of the word Holor"},{"location":"about/origin_of_holor.html#origin-of-the-word-holor","text":"The name of the library pays homage to the work of Parry Moon and Domina Eberle Spencer, who coined the term Holor : The word holor indicates a mathematical entity that is made up of one or more independent quantities. Examples of holors are complex numbers, vectors, matrices, tensors, and other hypernumbers. -- Parry Moon and Domina Eberle Spencer 1 Moon and Spencer define holors (from the Greek \u1f45\u03bb\u03bf\u03c2 , a whole) as collections of indipendent elements, or merates (from the Greek \u03bc\u03ad\u03c1\u03bf\u03c2 , a part). In their definition, holors are characterized by two fundamental qualities: valence \\(N\\) : which indicates the number of dimensions . plethos \\(n_i\\) : which indicates the number of elements in the \\(i\\) -th dimension. Moon and Spencer also introduce a general index notation to identify the merates of a holor: a single dimensional holor with three merates is denoted as \\(v^i = (v^1, v^2, v^3)\\) , a bi-dimensional holor with \\(2 \\times 2\\) elements is denoted as \\(A^{ij} = (A^{1,1}, A^{1,2}, A^{2,1}, A^{2,2})\\) , and so on. The definition of holors is purposedly broad so as to encompass under a unique formulation a large number of mathematical entities, such as matrices, tensors, complex numbers, quaternions, etcetera. Figure 1 illustrates some examples of holors. Figure 1 : Some examples of holors: a) a 3D matrix; b) a complex number; c) a quaternion. The Theory of Holors goes further to elaborate an algebra of holors, an operation called \\(\\gamma\\) -product that allows to modify the characteristics (valence, positions of indices, symmetry or antisymmetry) of holors, transformations. It also provides definitions for notable classes of holors, like tensors, akinetors, oudors. Parry Moon and Domina Eberle Spencer, Theory of Holors: a generalization of tensors , Cambridge, England: Cambridge University Press, 1986 \u21a9","title":"Origin of the word Holor"},{"location":"api/index.html","text":"C++ API \u00b6 Public classes \u00b6 Class Description Layout Class that provides the mapping between the indices a Holor container and the locations in the memory where the elements are stored. Holor Class that implements a general N -dimensional container for elements of type T and that owns the memory where the elements are stored. HolorRef Class that implements a general N -dimensional container for elements of type T and that does not own the memory where the elements are stored. Other Facilities \u00b6 Name Description Indices HolorLib uses an index notation to provide the interface to access individual elements or range of elements stored in a Holor container. Exceptions HolorLib defines some exceptions that may be thrown by runtime assertions.","title":"C++ API"},{"location":"api/index.html#c-api","text":"","title":"C++ API"},{"location":"api/index.html#public-classes","text":"Class Description Layout Class that provides the mapping between the indices a Holor container and the locations in the memory where the elements are stored. Holor Class that implements a general N -dimensional container for elements of type T and that owns the memory where the elements are stored. HolorRef Class that implements a general N -dimensional container for elements of type T and that does not own the memory where the elements are stored.","title":"Public classes"},{"location":"api/index.html#other-facilities","text":"Name Description Indices HolorLib uses an index notation to provide the interface to access individual elements or range of elements stored in a Holor container. Exceptions HolorLib defines some exceptions that may be thrown by runtime assertions.","title":"Other Facilities"},{"location":"api/Exceptions.html","text":"Exceptions and Runtime Assertions \u00b6 HolorLib implements many checks at compile time, using concepts and static assertions. However, some checks (e.g., verifying if an argument is within a correct range) can be performed only at runtime. In order to allow a certain fleibility with these runtime checks, the library implements a system that assigns different levels of assertions so that only the checks below a level that is set during compilation may be enabled (refer to Bjarne Stroustrup's The C++ Programming Language for more details). HolorLib defines some exceptions that may be thrown by these runtime assertions. Exceptions \u00b6 Defined in header common/exceptions.h , within the namespace holor :: exception . HolorInvalidArgument \u00b6 signature \u00b6 struct HolorInvalidArgument : public std :: invalid_argument constructor \u00b6 HolorInvalidArgument ( const std :: string & p ) : std :: invalid_argument ( p ){}; The argument p is a message. HolorRuntimeError \u00b6 signature \u00b6 struct HolorRuntimeError : public std :: runtime_error constructor \u00b6 HolorRuntimeError ( const std :: string & p ) : std :: runtime_error ( p ){}; The argument p is a message. Runtime Assertions \u00b6 Defined in header common/runtime_assertions.h , within the namespace holor :: assert . HolorLib introduces three assertion levels for runtime assertions. These levels can be assigned to runtime assertions in order to control which assertions may or may not be enabled. The three levels are: enum AssertionLevel { no_checks = 0 , release = 1 , debug = 2 }; To control which level of assertions is used in an application, the Library may be installed using Cmake with the option DEFINE_HOLOR_ASSERT_LEVEL , for example setting -DDEFINE_HOLOR_ASSERT_LEVEL=AssertionLevel::no_checks .","title":"Exceptions"},{"location":"api/Exceptions.html#exceptions-and-runtime-assertions","text":"HolorLib implements many checks at compile time, using concepts and static assertions. However, some checks (e.g., verifying if an argument is within a correct range) can be performed only at runtime. In order to allow a certain fleibility with these runtime checks, the library implements a system that assigns different levels of assertions so that only the checks below a level that is set during compilation may be enabled (refer to Bjarne Stroustrup's The C++ Programming Language for more details). HolorLib defines some exceptions that may be thrown by these runtime assertions.","title":"Exceptions and Runtime Assertions"},{"location":"api/Exceptions.html#exceptions","text":"Defined in header common/exceptions.h , within the namespace holor :: exception .","title":"Exceptions"},{"location":"api/Exceptions.html#holorinvalidargument","text":"","title":"HolorInvalidArgument"},{"location":"api/Exceptions.html#holorruntimeerror","text":"","title":"HolorRuntimeError"},{"location":"api/Exceptions.html#runtime-assertions","text":"Defined in header common/runtime_assertions.h , within the namespace holor :: assert . HolorLib introduces three assertion levels for runtime assertions. These levels can be assigned to runtime assertions in order to control which assertions may or may not be enabled. The three levels are: enum AssertionLevel { no_checks = 0 , release = 1 , debug = 2 }; To control which level of assertions is used in an application, the Library may be installed using Cmake with the option DEFINE_HOLOR_ASSERT_LEVEL , for example setting -DDEFINE_HOLOR_ASSERT_LEVEL=AssertionLevel::no_checks .","title":"Runtime Assertions"},{"location":"api/Holor.html","text":"Holor class \u00b6 Defined in header holor/holor.h , within the namespace holor . template < typename T , size_t N > requires ( N > 0 ) class Holor ; This class implements a general N -dimensional container that owns the memory where the elements are stored. The elements in the container need not to be numerical types, but can be of a generic type T . Holors are implemented with a row-major representation, i.e., the elements of the last dimension of the container are contiguous. Template parameters \u00b6 Name Description N number of dimensions of the container. It must be N>0 T type of the elements stored in the container Member types and aliases \u00b6 Name Description order number of dimensions in the container (equal to N ) value_type type of the elements in the container (equal to T ) iterator type of the iterator for the container const_iterator type of the const_iterator for the container reverse_iterator type of the reverse_iterator for the container const_reverse_iterator type of the const_reverse_iterator for the container Public Member functions \u00b6 Constructors \u00b6 signature \u00b6 Holor (); Holor ( const Holor < T , N >& holor ); Holor ( Holor < T , N >&& holor ); template < class Container > requires assert :: SizedTypedContainer < Container , size_t , N > explicit Holor ( const Container & lengths ); template < class Container > requires assert :: ResizeableTypedContainer < Container , size_t > explicit Holor ( const Container & lengths ); template < typename U > requires ( std :: convertible_to < U , T > ) explicit Holor ( const HolorRef < U , N >& ref ); Holor ( holor :: nested_list < T , N > init ); brief \u00b6 Create a Holor object, either as an empty holor with 0-length dimensions (1), or initializing it from another Holor (2, 3) or HolorRef (6), or providing the lenghts (number of elements) in each dimension (4, 5), or by passing as arguments a nested list with the elements (7). parameters \u00b6 holor : Holor object used to initialize the created Holor from. lengths : number of elements per dimension (a container such as std :: vector < size_t > or std :: array < size_t , N > ). ref : HolorRef object used to initialize the created Holor from. init : nested list of the elements to be inserted in the container. return \u00b6 A Holor container. Assignments \u00b6 signature \u00b6 Holor & operator = ( Holor < T , N >&& holor ); Holor & operator = ( Holor < T , N >&& holor ); Holor & operator = ( holor :: nested_list < T , N > init ); brief \u00b6 Assign to a Holor. parameters \u00b6 holor : Holor object to assign from. init : nested list of the elements to be assigned in the container. return \u00b6 A reference to the Holor container. Iterators \u00b6 begin \u00b6 signature \u00b6 auto begin (); brief \u00b6 Returns an iterator to the beginning. end \u00b6 signature \u00b6 auto end (); brief \u00b6 Returns an iterator to the end. cbegin \u00b6 signature \u00b6 auto cbegin () const ; brief \u00b6 Returns a constant iterator to the beginning. cend \u00b6 signature \u00b6 auto cend () const ; brief \u00b6 Returns a constant iterator to the end. rbegin \u00b6 signature \u00b6 auto rbegin (); brief \u00b6 Returns a reverse iterator to the beginning. rend \u00b6 signature \u00b6 auto rend (); brief \u00b6 Returns a reverse iterator to the end. crebegin \u00b6 signature \u00b6 auto crbegin () const ; brief \u00b6 Returns a constant reverse iterator to the beginning. crend \u00b6 signature \u00b6 auto crend () const ; brief \u00b6 Returns a constant reverse iterator to the end. Get/Set functions \u00b6 layout \u00b6 signature \u00b6 const Layout < N >& layout (); brief \u00b6 Get the Layout used by the Holor to map indices to memory locations. return \u00b6 A Layout. lengths \u00b6 signature \u00b6 auto lengths () const ; brief \u00b6 Get the lengths, i.e., the number of elements that the container has per each dimension. return \u00b6 A std::array with the length of all dimensions of the container. set_lengths \u00b6 signature \u00b6 template < typename ... Lengths > requires (( sizeof ...( Lengths ) == N ) && ( assert :: all ( std :: is_convertible_v < Lengths , size_t > ...)) ) void set_lengths ( Lengths && ... lengths ); template < class Container > requires assert :: SizedTypedContainer < Container , size_t , N > void set_lengths ( const Container & lengths ); template < class Container > requires assert :: ResizeableTypedContainer < Container , size_t > void set_lengths ( const Container & lengths ); brief \u00b6 Set the lengths of the container, resizing it. parameters \u00b6 lengths : number of elements per dimension ( either a container such as std :: vector < size_t > and std :: array < size_t , N > , or a variadic argument.). length \u00b6 signature \u00b6 auto length ( size_t dim ) const ; brief \u00b6 Get the number of elements that the container has along the dimension dim . parameters \u00b6 dim : the dimension queried. There is no check on the validity of this argument. return \u00b6 The function returns a single legnth (a size_t ). set_length \u00b6 signature \u00b6 void set_length ( size_t dim , size_t length ) brief \u00b6 Change a single length of the container. parameters \u00b6 dim : the dimension queried. length : the new value. size \u00b6 signature \u00b6 size_t size () const ; brief \u00b6 Get the total number of elements in the container. return \u00b6 Return the number of elements in the container, as a size_t . data \u00b6 signature \u00b6 T * data (); const T * data (); brief \u00b6 Get a flat access to the data contained in the container. return \u00b6 A pointer to the data stored in the container. data_vector \u00b6 signature \u00b6 auto data_vector () const ; brief \u00b6 Get a copy of the container's data. return \u00b6 A std::vector with the data. Indexing functions \u00b6 operator() \u00b6 signature \u00b6 template < SingleIndex ... Dims > requires (( sizeof ...( Dims ) == N ) ) T & operator ()( Dims && ... dims ); template < SingleIndex ... Dims > requires (( sizeof ...( Dims ) == N ) ) const T operator ()( Dims && ... dims ) const ; brief \u00b6 Access a single element in the container. parameters \u00b6 dims : pack of indices, one per dimension of the Holor container, given either as a parameter pack or as an array of SingleIndex elements (Refer to Indices for more details). Warning When indexing a Holor, the conversion from indices to a memory location performed by the Layout may throw an holor::exception::HolorRuntimeError if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The element in the Holor at the selected coordinates. Slicing functions \u00b6 operator() \u00b6 signature \u00b6 template < typename ... Args > requires ( impl :: ranged_index_pack < Args ... > () && ( sizeof ...( Args ) == N ) ) auto operator ()( Args && ... args ); brief \u00b6 Access a slice of the container. parameters \u00b6 args : parameters pack. Each element of the pack must be either a SingleIndex or a RangeIndex , and at least one of them must be a RangeIndex . Refer to Indices for more details. Warning When slicing a Holor, the conversion from indices to a memory location performed by the Layout may throw an holor::exception::HolorRuntimeError if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 A slice as a HolorRef. The number of dimensions of the returned holorRef depends on the input arguments, as each SingleIndex passed in the parameters pack collapses one dimension. row \u00b6 signature \u00b6 auto row ( size_t i ); const auto row ( size_t i ) const ; brief \u00b6 Get a single row of the container. parameters \u00b6 i : selects the i -th row. Warning When slicing a row of the Holor an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 the slice corresponding to the i -th row. This slice is a HolorRef with N-1 dimensions. Warning Since the slice has N-1 dimensions, this function is available only for Holor containers with N>1 . col \u00b6 signature \u00b6 auto col ( size_t i ); const auto col ( size_t i ) const ; brief \u00b6 Get a single column of the container. parameters \u00b6 i : selects the i -th column. Warning When slicing a column of the Holor an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The slice corresponding to the i -th column. This slice is a HolorRef with N-1 dimensions. Warning Since the slice has N-1 dimensions, this function is available only for Holor containers with N>1 . slice \u00b6 signature \u00b6 template < size_t M > requires ( M < N ) auto slice ( size_t i ); template < size_t M > requires ( M < N ) const auto slice ( size_t i ) const ; brief \u00b6 Get the i -th slice of a single dimension (e.g., the fifth row or the second column) template parameters \u00b6 M is the dimension to be sliced. 0 is a row, 1 is a column, ... parameters \u00b6 i is the index of the slice to be taken along the M -th dimension. Warning When slicing a dimension of the Holor an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The slice corresponding to the i -th coordinate along the M -th dimension. This slice is a HolorRef with N-1 dimensions. Warning Since the slice has N-1 dimensions, this function is available only for Holor containers with N>1 . Moreover, it must be M<N . Non-Member functions \u00b6 equality operator== \u00b6 signature \u00b6 template < typename T , size_t N > requires std :: equality_comparable < T > bool operator == ( const Holor < T , N >& h1 , const Holor < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator == ( const HolorRef < T , N >& h1 , const Holor < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator == ( const Holor < T , N >& h1 , const HolorRef < T , N >& h2 ); brief \u00b6 Comparison operator that verifies the equality of two HolorLib containers with the same dimension N and type of elements T . Note Two Holor containers are considered equal if they have the same layout and contain the same elements. A Holor and a HolorRef container are considered equal if they have the same lengths across all dimensions (but their layouts may be different) and store the same elements. template parameter \u00b6 N : the dimension of the two container to be compared. T : the type of the elements in the container. parameter \u00b6 h1 : left hand side of the comparison. h2 : right hand side of the comparison. return \u00b6 true if the two containers are equal, false otherwise inequality operator!= \u00b6 signature \u00b6 template < typename T , size_t N > requires std :: equality_comparable < T > bool operator != ( const Holor < T , N >& h1 , const Holor < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator != ( const HolorRef < T , N >& h1 , const Holor < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator != ( const Holor < T , N >& h1 , const HolorRef < T , N >& h2 ); brief \u00b6 Comparison operator that verifies the inequality of two HolorLib containers with the same dimension N and type of elements T . Note Two Holor containers are considered equal if they have the same layout and contain the same elements. A Holor and a HolorRef container are considered equal if they have the same lengths across all dimensions (but their layouts may be different) and store the same elements. template parameter \u00b6 N : the dimension of the two container to be compared. T : the type of the elements in the container. parameter \u00b6 h1 : left hand side of the comparison. h2 : right hand side of the comparison. return \u00b6 true if the two containers are not equal, false otherwise.","title":"Holor"},{"location":"api/Holor.html#holor-class","text":"Defined in header holor/holor.h , within the namespace holor . template < typename T , size_t N > requires ( N > 0 ) class Holor ; This class implements a general N -dimensional container that owns the memory where the elements are stored. The elements in the container need not to be numerical types, but can be of a generic type T . Holors are implemented with a row-major representation, i.e., the elements of the last dimension of the container are contiguous.","title":"Holor class"},{"location":"api/Holor.html#template-parameters","text":"Name Description N number of dimensions of the container. It must be N>0 T type of the elements stored in the container","title":"Template parameters"},{"location":"api/Holor.html#member-types-and-aliases","text":"Name Description order number of dimensions in the container (equal to N ) value_type type of the elements in the container (equal to T ) iterator type of the iterator for the container const_iterator type of the const_iterator for the container reverse_iterator type of the reverse_iterator for the container const_reverse_iterator type of the const_reverse_iterator for the container","title":"Member types and aliases"},{"location":"api/Holor.html#public-member-functions","text":"","title":"Public Member functions"},{"location":"api/Holor.html#constructors","text":"","title":"Constructors"},{"location":"api/Holor.html#assignments","text":"","title":"Assignments"},{"location":"api/Holor.html#iterators","text":"","title":"Iterators"},{"location":"api/Holor.html#begin","text":"","title":"begin"},{"location":"api/Holor.html#end","text":"","title":"end"},{"location":"api/Holor.html#cbegin","text":"","title":"cbegin"},{"location":"api/Holor.html#cend","text":"","title":"cend"},{"location":"api/Holor.html#rbegin","text":"","title":"rbegin"},{"location":"api/Holor.html#rend","text":"","title":"rend"},{"location":"api/Holor.html#crebegin","text":"","title":"crebegin"},{"location":"api/Holor.html#crend","text":"","title":"crend"},{"location":"api/Holor.html#getset-functions","text":"","title":"Get/Set functions"},{"location":"api/Holor.html#layout","text":"","title":"layout"},{"location":"api/Holor.html#lengths","text":"","title":"lengths"},{"location":"api/Holor.html#set_lengths","text":"","title":"set_lengths"},{"location":"api/Holor.html#length","text":"","title":"length"},{"location":"api/Holor.html#set_length","text":"","title":"set_length"},{"location":"api/Holor.html#size","text":"","title":"size"},{"location":"api/Holor.html#data","text":"","title":"data"},{"location":"api/Holor.html#data_vector","text":"","title":"data_vector"},{"location":"api/Holor.html#indexing-functions","text":"","title":"Indexing functions"},{"location":"api/Holor.html#operator","text":"","title":"operator()"},{"location":"api/Holor.html#slicing-functions","text":"","title":"Slicing functions"},{"location":"api/Holor.html#operator_1","text":"","title":"operator()"},{"location":"api/Holor.html#row","text":"","title":"row"},{"location":"api/Holor.html#col","text":"","title":"col"},{"location":"api/Holor.html#slice","text":"","title":"slice"},{"location":"api/Holor.html#non-member-functions","text":"","title":"Non-Member functions"},{"location":"api/Holor.html#equality-operator","text":"","title":"equality operator=="},{"location":"api/Holor.html#inequality-operator","text":"","title":"inequality operator!="},{"location":"api/HolorRef.html","text":"HolorRef class \u00b6 Defined in header holor/holor_ref.h , within the namespace holor . template < typename T , size_t N > requires ( N > 0 ) class HolorRef ; This class implements a general N -dimensional container that doesn't own the memory where the elements are stored. The elements in the container need not to be numerical types, but can be of a generic type T . Holors are implemented with a row-major representation, i.e., the elements of the last dimension of the container are contiguous. Template parameters \u00b6 Name Description N number of dimensions of the container. It must be N>0 T type of the elements stored in the container Member types and aliases \u00b6 Name Description order number of dimensions in the container (equal to N ) value_type type of the elements in the container (equal to T ) iterator type of the iterator for the container const_iterator type of the const_iterator for the container reverse_iterator type of the reverse_iterator for the container const_reverse_iterator type of the const_reverse_iterator for the container Public Member functions \u00b6 Constructors \u00b6 signature \u00b6 HolorRef (); HolorRef ( const HolorRef < T , N >& holor_ref ); HolorRef ( HolorRef < T , N >&& holor_ref ); HolorRef ( T * dataptr , const Layout < N >& layout ); template < class Container > requires assert :: SizedTypedContainer < Container , size_t , N > explicit HolorRef ( T * dataptr , const Container & lengths ); template < class Container > requires assert :: ResizeableTypedContainer < Container , size_t > explicit HolorRef ( T * dataptr , const Container & lengths ); brief \u00b6 Create a HolorRef object, either as an empty HolorRef with 0-length dimensions (1), or initializing it from another HolorRef (2, 3), or creating it from a pointer to a memory location and a Layout (4), or by creating it from a pointer to a memory location and a container of lengths. parameters \u00b6 holor_ref : HolorRef object used to initialize the created HolorRef. dataptr : pointer to the memory location where the elements are stored. layout : Layout used to initialize the way coordinates are mapped to memory locations. lenghts : number of elements along each individual dimension of the HolorRef container, given either as a compile-time size container (e.g. a std::array ) or as a dynamic size container (e.g., a std::vector ). return \u00b6 A HolorRef container. Assignments \u00b6 signature \u00b6 HolorRef & operator = ( HolorRef < T , N >&& holor_ref ); HolorRef & operator = ( HolorRef < T , N >&& holor_ref ); brief \u00b6 Assign to a HolorRef. parameters \u00b6 holor_ref : HolorRef object to assign from. return \u00b6 A reference to a HolorRef. Iterators \u00b6 begin \u00b6 signature \u00b6 auto begin (); brief \u00b6 Returns an iterator to the beginning. end \u00b6 signature \u00b6 auto end (); brief \u00b6 Returns an iterator to the end. cbegin \u00b6 signature \u00b6 auto cbegin () const ; brief \u00b6 Returns a constant iterator to the beginning. cend \u00b6 signature \u00b6 auto cend () const ; brief \u00b6 Returns a constant iterator to the end. rbegin \u00b6 signature \u00b6 auto rbegin (); brief \u00b6 Returns a reverse iterator to the beginning. rend \u00b6 signature \u00b6 auto rend (); brief \u00b6 Returns a reverse iterator to the end. crebegin \u00b6 signature \u00b6 auto crbegin () const ; brief \u00b6 Returns a constant reverse iterator to the beginning. crend \u00b6 signature \u00b6 auto crend () const ; brief \u00b6 Returns a constant reverse iterator to the end. Get/Set functions \u00b6 layout \u00b6 signature \u00b6 const Layout < N >& layout (); brief \u00b6 Get the Layout used by the Holor to map indices to memory locations. return \u00b6 a Layout. HolorRef lengths \u00b6 signature \u00b6 auto lengths () const ; auto lengths ( size_t dim ) const ; brief \u00b6 Get the lengths, i.e., the number of elements that the container has per each dimension. parameters \u00b6 dim : request to get only the lenght for the dim dimension. There is no check on the validity of this argument. return \u00b6 When called without arguments, the function returns a std::array with the lenght of all dimensions ofthe container. When the argument dim is passed, the function returns a single legnth (a size_t ). size \u00b6 signature \u00b6 size_t size () const ; brief \u00b6 Get the total number of elements in the container. return \u00b6 Return the number of elements in the container, a size_t . dataptr \u00b6 signature \u00b6 T * dataptr (); const T * dataptr (); brief \u00b6 Get a flat access to the memory that stores the elements contained in the container. return \u00b6 A pointer to the memory location where the elements are stored. Indexing functions \u00b6 operator() \u00b6 signature \u00b6 template < SingleIndex ... Dims > requires (( sizeof ...( Dims ) == N ) ) T & operator ()( Dims && ... dims ); template < SingleIndex ... Dims > requires (( sizeof ...( Dims ) == N ) ) const T operator ()( Dims && ... dims ) const ; brief \u00b6 Access a single element in the container. parameters \u00b6 dims : pack of indices, one per dimension of the Holor container, given either as a parameter pack or as an array of SingleIndex elements (Refer to Indices for more details). Warning When indexing a Holor, the conversion from indices to a memory location performed by the Layout may throw an holor::exception::HolorRuntimeError if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The element in the Holor at the selected coordinates. Slicing functions \u00b6 operator() \u00b6 signature \u00b6 template < typename ... Args > requires ( impl :: ranged_index_pack < Args ... > () && ( sizeof ...( Args ) == N ) ) auto operator ()( Args && ... args ); brief \u00b6 Access a slice of the container. parameters \u00b6 args : parameters pack. Each element of the pack must be either a SingleIndex or a RangeIndex , and at least one of them must be a RangeIndex . Refer to Indices for more details. Warning When slicing a Holor, the conversion from indices to a memory location performed by the Layout may throw an holor::exception::HolorRuntimeError if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 A slice as a HolorRef. The number of dimensions of the returned holorRef depends on the input arguments, as each SingleIndex passed in the parameters pack collapses one dimension. row \u00b6 signature \u00b6 auto row ( size_t i ); const auto row ( size_t i ) const ; brief \u00b6 Get a single row of the container. parameters \u00b6 i : selects the i -th row. Warning When slicing a row of the Holor an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 the slice corresponding to the i -th row. This slice is a HolorRef with N-1 dimensions. Warning Since the slice has N-1 dimensions, this function is available only for Holor containers with N>1 . col \u00b6 signature \u00b6 HolorRef < T , N -1 > col ( size_t i ); const HolorRef < T , N -1 > col ( size_t i ) const ; brief \u00b6 Get a single column of the container. parameters \u00b6 i : selects the i -th column. Warning When slicing a column of the Holor an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The slice corresponding to the i -th column. This slice is a HolorRef with N-1 dimensions. Warning Since the slice has N-1 dimensions, this function is available only for Holor containers with N>1 . slice \u00b6 signature \u00b6 template < size_t M > requires ( M < N ) auto slice ( size_t i ); template < size_t M > requires ( M < N ) const auto slice ( size_t i ) const ; brief \u00b6 Get the i -th slice of a single dimension (e.g., the fifth row or the second column) template parameters \u00b6 M is the dimension to be sliced. 0 is a row, 1 is a column, ... parameters \u00b6 i is the index of the slice to be taken along the M -th dimension. Warning When slicing a dimension of the Holor an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The slice corresponding to the i -th coordinate along the M -th dimension. This slice is a HolorRef with N-1 dimensions. Warning Since the slice has N-1 dimensions, this function is available only for Holor containers with N>1 . Moreover, it must be M<N . Non-Member functions \u00b6 equality operator== \u00b6 signature \u00b6 template < typename T , size_t N > requires std :: equality_comparable < T > bool operator == ( const HolorRef < T , N >& h1 , const HolorRef < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator == ( const HolorRef < T , N >& h1 , const Holor < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator == ( const Holor < T , N >& h1 , const HolorRef < T , N >& h2 ); brief \u00b6 Comparison operator that verifies the equality of two HolorLib containers with the same dimension N and type of elements T . Note Two HolorRef containers or a HolorRef and a Holor container are considered equal if they have the same lengths and contain the same elements (but their layouts may be different). template parameter \u00b6 N : the dimension of the two container to be compared. T : the type of the elements in the container. parameter \u00b6 h1 : left hand side of the comparison. h2 : right hand side of the comparison. return \u00b6 true if the two containers are equal, false otherwise inequality operator!= \u00b6 signature \u00b6 template < typename T , size_t N > requires std :: equality_comparable < T > bool operator != ( const HolorRef < T , N >& h1 , const HolorRef < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator != ( const HolorRef < T , N >& h1 , const Holor < T , N >& h2 ); template < typename T , size_t N > requires std :: equality_comparable < T > bool operator != ( const Holor < T , N >& h1 , const HolorRef < T , N >& h2 ); brief \u00b6 Comparison operator that verifies the inequality of two HolorLib containers with the same dimension N and type of elements T . Note Two HolorRef containers or a HolorRef and a Holor container are considered equal if they have the same lengths and contain the same elements (but their layouts may be different). template parameter \u00b6 N : the dimension of the two container to be compared. T : the type of the elements in the container. parameter \u00b6 h1 : left hand side of the comparison. h2 : right hand side of the comparison. return \u00b6 true if the two containers are not equal, false otherwise.","title":"HolorRef"},{"location":"api/HolorRef.html#holorref-class","text":"Defined in header holor/holor_ref.h , within the namespace holor . template < typename T , size_t N > requires ( N > 0 ) class HolorRef ; This class implements a general N -dimensional container that doesn't own the memory where the elements are stored. The elements in the container need not to be numerical types, but can be of a generic type T . Holors are implemented with a row-major representation, i.e., the elements of the last dimension of the container are contiguous.","title":"HolorRef class"},{"location":"api/HolorRef.html#template-parameters","text":"Name Description N number of dimensions of the container. It must be N>0 T type of the elements stored in the container","title":"Template parameters"},{"location":"api/HolorRef.html#member-types-and-aliases","text":"Name Description order number of dimensions in the container (equal to N ) value_type type of the elements in the container (equal to T ) iterator type of the iterator for the container const_iterator type of the const_iterator for the container reverse_iterator type of the reverse_iterator for the container const_reverse_iterator type of the const_reverse_iterator for the container","title":"Member types and aliases"},{"location":"api/HolorRef.html#public-member-functions","text":"","title":"Public Member functions"},{"location":"api/HolorRef.html#constructors","text":"","title":"Constructors"},{"location":"api/HolorRef.html#assignments","text":"","title":"Assignments"},{"location":"api/HolorRef.html#iterators","text":"","title":"Iterators"},{"location":"api/HolorRef.html#begin","text":"","title":"begin"},{"location":"api/HolorRef.html#end","text":"","title":"end"},{"location":"api/HolorRef.html#cbegin","text":"","title":"cbegin"},{"location":"api/HolorRef.html#cend","text":"","title":"cend"},{"location":"api/HolorRef.html#rbegin","text":"","title":"rbegin"},{"location":"api/HolorRef.html#rend","text":"","title":"rend"},{"location":"api/HolorRef.html#crebegin","text":"","title":"crebegin"},{"location":"api/HolorRef.html#crend","text":"","title":"crend"},{"location":"api/HolorRef.html#getset-functions","text":"","title":"Get/Set functions"},{"location":"api/HolorRef.html#layout","text":"","title":"layout"},{"location":"api/HolorRef.html#lengths","text":"","title":"lengths"},{"location":"api/HolorRef.html#size","text":"","title":"size"},{"location":"api/HolorRef.html#dataptr","text":"","title":"dataptr"},{"location":"api/HolorRef.html#indexing-functions","text":"","title":"Indexing functions"},{"location":"api/HolorRef.html#operator","text":"","title":"operator()"},{"location":"api/HolorRef.html#slicing-functions","text":"","title":"Slicing functions"},{"location":"api/HolorRef.html#operator_1","text":"","title":"operator()"},{"location":"api/HolorRef.html#row","text":"","title":"row"},{"location":"api/HolorRef.html#col","text":"","title":"col"},{"location":"api/HolorRef.html#slice","text":"","title":"slice"},{"location":"api/HolorRef.html#non-member-functions","text":"","title":"Non-Member functions"},{"location":"api/HolorRef.html#equality-operator","text":"","title":"equality operator=="},{"location":"api/HolorRef.html#inequality-operator","text":"","title":"inequality operator!="},{"location":"api/Indexes.html","text":"Indices and Ranges of Indices \u00b6 Defined in header holor/indexes.h , within the namespace holor . The individual elements within a Holor or HolorRef container are identified by a set of indices. These indices indicate the position of the element along each axis of the container. This index notation is used to provide the interface to access individual elements or range of elements stored in a Holor container. HolorLib introduces a few concepts to describe indices and ranges of indices. SingleIndex \u00b6 This concept describes an index, a non-negative natural number that represent a position along an axis of the container. This concept is instrumental to access an individual element of the container, and it is implemented as: template < typename T > concept SingleIndex = std :: integral < std :: remove_cvref_t < T >> && std :: convertible_to < T , size_t > ; RangeIndex \u00b6 This concept describes a range of indices, which is instrumental to access a slice of contiguous elements in the container. This concept is implemented as: template < typename T > concept RangeIndex = std :: convertible_to < T , range > ; The implementation of a RangeIndex is based upon the holor::range structure. holor::range \u00b6 struct range { size_t start_ ; size_t end_ ; size_t step_ ; }; brief \u00b6 Structure that represents a range of indices. members \u00b6 start_ : beginning of the range. end_ : end of the range (this element is included in the range. step_ : number of steps between consecutive indices. Warning The field step_ to select a range of spaced elements is not yet supported and it may be removed. constructor \u00b6 holor :: range ( size_t start , size_t end , size_t step = 1 ); exceptions The constructor throws an holor::exception::HolorRuntimeError if its arguments do not implement a meaningful range of indices, i.e., if they do not satisfy (start>=0) && (end>start) && (step>0) . The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. Note range{1, 5, 1} is equivalent to 1:5 in Matlab. range{1, 5, 2} yields the set of indices 1, 3, 5. Index \u00b6 This final concept describes a type that is either a SingleIndex or a RangeIndex and tha can be used to access an individual element of a Holor container or a slice with multiple elements. It is defined as: template < typename T > concept Index = SingleIndex < T > || RangeIndex < T > ;","title":"Indices"},{"location":"api/Indexes.html#indices-and-ranges-of-indices","text":"Defined in header holor/indexes.h , within the namespace holor . The individual elements within a Holor or HolorRef container are identified by a set of indices. These indices indicate the position of the element along each axis of the container. This index notation is used to provide the interface to access individual elements or range of elements stored in a Holor container. HolorLib introduces a few concepts to describe indices and ranges of indices.","title":"Indices and Ranges of Indices"},{"location":"api/Indexes.html#singleindex","text":"This concept describes an index, a non-negative natural number that represent a position along an axis of the container. This concept is instrumental to access an individual element of the container, and it is implemented as: template < typename T > concept SingleIndex = std :: integral < std :: remove_cvref_t < T >> && std :: convertible_to < T , size_t > ;","title":"SingleIndex"},{"location":"api/Indexes.html#rangeindex","text":"This concept describes a range of indices, which is instrumental to access a slice of contiguous elements in the container. This concept is implemented as: template < typename T > concept RangeIndex = std :: convertible_to < T , range > ; The implementation of a RangeIndex is based upon the holor::range structure.","title":"RangeIndex"},{"location":"api/Indexes.html#index","text":"This final concept describes a type that is either a SingleIndex or a RangeIndex and tha can be used to access an individual element of a Holor container or a slice with multiple elements. It is defined as: template < typename T > concept Index = SingleIndex < T > || RangeIndex < T > ;","title":"Index"},{"location":"api/Layout.html","text":"Layout class \u00b6 Defined in header holor/layout.h , within the namespace holor . template < size_t N > requires ( N > 0 ) class Layout This class implements the mapping between the indices a Holor container and the locations in the memory where the elements are stored. It uses the idea of generalized layouts from the standard library, i.e., it is based on the fact that the elements of a Holor or HolorRef are stored as a 1D data sequence following a row-major representation. A layout contains three main pieces of attributes: offset : the offset in the contiguous memory of the first element indexed by the layout. lengths : the numbers of elements along every dimension of the layout. strides : the distances in the 1D memory sequence between successive elements in individual dimensions of the layout. Note For a Layout with N dimensions, both the length array and the stride array must be size N . A Layout supports two fundamental operations: Indexing : this operation provides a map from the coordinates in the container to the index in memory of the selected element; Slicing : this operation allows to select a subset of elements from a container by computing a new Layout that provides the needed information to index them. Template parameters \u00b6 Name Description N number of dimensions in the layout. It must be N>0 Member types and aliases \u00b6 Name Description order static constexpr member equal to N Public Member functions \u00b6 Constructors \u00b6 signature \u00b6 Layout (); Layout ( const Layout < N >& layout ); Layout ( Layout < N >&& layout ); template < class Container > requires assert :: SizedTypedContainer < Container , size_t , N > explicit Layout ( const Container & lengths ); template < class Container > requires assert :: ResizeableTypedContainer < Container , size_t > explicit Layout ( const Container & lengths ); template < typename ... Lengths > requires (( sizeof ...( Lengths ) == N ) && ( assert :: all ( std :: is_convertible_v < Lengths , size_t > ...)) ) explicit Layout ( Lengths && ... lengths ); brief \u00b6 Create a Layout object, either as an empty layout with 0-length dimensions (1), or initializing it from another layout (2, 3), or providing the lenghts (number of elements) mapped in each dimension (4, 5, 6). parameters \u00b6 layout : another layout to be used to initialize the created layout. lengths : number of elements per dimension ( either a container such as std :: vector < size_t > and std :: array < size_t , N > , or a variadic argument.). Warning When constructing a Layout from a container of lengths , this container must have N elements. This check is performed as a static assert for fixed size containers ( e.g. a std::array ) and as a runtime assert for dynamic size containers (e.g. a std::vector ). In this second case, the constructor would throws an holor::exception::HolorRuntimeError exception . The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 A Layout. Assignments \u00b6 signature \u00b6 Layout < N >& operator = ( const Layout < N >& layout ); Layout < N >& operator = ( Layout < N >&& layout ); brief \u00b6 Assign to a Layout from another Layout. parameters \u00b6 layout : another layout to assign from. return \u00b6 A reference to the Layout. Get/Set functions \u00b6 dimensions \u00b6 signature \u00b6 constexpr size_t dimensions () const ; brief \u00b6 get the number of dimensions of the layout. return \u00b6 the number N of dimensions of the layout. size \u00b6 signature \u00b6 size_t size () const ; brief \u00b6 Get the size the layout. return \u00b6 The total number of elements mapped by the layout. offset \u00b6 signature \u00b6 size_t offset () const ; brief \u00b6 Get the offset of the layout. This is a const function. return \u00b6 The offset of the position of first element in the container with respect to the beginning of the memory where the elements are stored. lengths \u00b6 signature \u00b6 std :: array < size_t , N > lengths (); brief \u00b6 Get the lengths of the layout. return \u00b6 The lengths (number of elements per dimension) of the layout. set_lengths \u00b6 signature \u00b6 template < typename ... Lengths > requires (( sizeof ...( Lengths ) == N ) && ( assert :: all ( std :: is_convertible_v < Lengths , size_t > ...)) ) void set_lengths ( Lengths && ... lengths ); template < class Container > requires assert :: SizedTypedContainer < Container , size_t , N > void set_lengths ( const Container & lengths ); template < class Container > requires assert :: ResizeableTypedContainer < Container , size_t > void set_lengths ( const Container & lengths ); brief \u00b6 Set the lengths of the layout. parameters \u00b6 lengths : number of elements per dimension ( either a container such as std :: vector < size_t > and std :: array < size_t , N > , or a variadic argument.). Warning When constructing a Layout from a container of lengths , this container must have N elements. This check is performed as a static assert for fixed size containers ( e.g. a std::array ) and as a runtime assert for dynamic size containers (e.g. a std::vector ). In this second case, the constructor would throws an holor::exception::HolorRuntimeError exception . The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. length \u00b6 signature \u00b6 auto length ( size_t dim ) const ; brief \u00b6 Get a length of a dimension of the layout. parameters \u00b6 dim : the dimension queried. There is no check to verify if the value dim is feasible. return \u00b6 The length along a dimension (number of elements in that dimension). set_length \u00b6 signature \u00b6 void set_length ( size_t dim , size_t length ) brief \u00b6 Set a single length of the layout. parameters \u00b6 dim : the dimension queried. length : the new value. Warning When changing a length, the dimension dim must be a valid dimension and the new value length msut be strictly positive. These checks are performed as a runtime assert for dynamic size containers and the function throws an holor::exception::HolorRuntimeError exception if the check fails. Refer to Exceptions for more details. strides \u00b6 signature \u00b6 std :: array < size_t , N > strides () const ; brief \u00b6 Get the strides of the layout, i.e., the distances in the memory sequence between consecutive elements of the Holor along its dimensions. return \u00b6 The strides of the layout. stride \u00b6 signature \u00b6 auto strides ( size_t dim ) const ; brief \u00b6 Get the stride along a single dimension of the layout, i.e., the distance in the memory sequence between consecutive elements of the Holor in a dimension. parameters \u00b6 dim : the dimension queried. There is no check to verify if the value dim is feasible. return \u00b6 The stride of the layout along the dimension dim . Indexing functions \u00b6 operator() \u00b6 signature \u00b6 template < SingleIndex ... Dims > requires (( sizeof ...( Dims ) == N ) ) size_t operator ()( Dims && ... dims ) const ; template < SingleIndex ID > size_t operator ()( std :: array < ID , N > dims ) const ; brief \u00b6 Get the position in memory of a single element according to the mapping described in the Layout. parameters \u00b6 dims : the coordinates of the element accessed, given either as a parameter pack or as an array of SingleIndex elements (Refer to Indices for more details). Warning When indexing a Layout using a parameter pack (signature 1.) an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. This check is not performed when using the signature 2. return \u00b6 The position of the element in the 1D data sequence. Slicing functions \u00b6 operator() \u00b6 signature \u00b6 template < typename ... Args > requires ( impl :: ranged_index_pack < Args ... > () && ( sizeof ...( Args ) == N ) ) auto operator ()( Args && ... args ) const ; brief \u00b6 Function for extracting a slice from the Layout. Singleton dimensions (dimensions that are reduced to a single element) are removed. example \u00b6 using namespace holor ; Layout < 2 > my_layout ( 2 , 2 ); //two dimensional Layout describing a 2x2 container auto row = my_layout ( 0 , range { 0 , 1 }); // This operation computes the Layout corresponding to the first row. The result would is a Layout<1> with lengths = [2]; parameters \u00b6 args : parameters pack. Each element of the pack must be either a SingleIndex or a RangeIndex , and at least one of them must be a RangeIndex . Refer to Indices for more details. Warning When slicing a Layout an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 The Layout that maps to the subset of elements included in the slice. slice_unreduced \u00b6 signature \u00b6 template < typename ... Args > requires ( impl :: ranged_index_pack < Args ... > () && ( sizeof ...( Args ) == N ) ) Layout < N > slice_unreduced ( Args && ... args ) const ; brief \u00b6 Function for extracting a slice from the Layout, but without removing singleton dimensions (dimensions with a single element). example \u00b6 using namespace holor ; Layout < 2 > my_layout ( 2 , 2 ); //two dimensional Layout describing a 2x2 container auto row = my_layout ( 0 , range { 0 , 1 }); // This operation compute the Layout corresponding to the first row. The result would is a Layout<2> with lengths = [1, 2]; parameter \u00b6 args : parameters pack. Each element of the pack indexes either an element or a range of elements along a dimension of the Layout. Warning When slicing a Layout an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 the Layout containing the indexed range of elements. In this case the Layout has dimension N , i.e. the dimensionality is not reduced. slice_dimension \u00b6 signature \u00b6 template < size_t Dim > requires ( ( Dim >= 0 ) && ( Dim < N ) ) Layout < N > slice_dimension ( range r ) const template < size_t Dim > requires ( ( Dim >= 0 ) && ( Dim < N ) ) auto slice_dimension ( size_t num ) const ; brief \u00b6 Function for indexing a single dimension of the Layout parameters \u00b6 r : the range of elements to be taken from the dimension Dim . r must indicate a valid range of indices in the dimension Dim . num : the index of the element to be taken from the dimension Dim . Warning When slicing a Layout an holor::exception::HolorRuntimeError exception maybe thrown if the arguments are outside the admissible range for each coordinate of the Layout. The compiler flag DDEFINE_ASSERT_LEVEL in the CMakeLists can be set to AssertionLevel::no_checks to exclude this check. Refer to Exceptions for more details. return \u00b6 A new Layout with N or N-1 dimensions, where the dimension Dim contains only the lements indexed by the range argument. Warning When slicing a Layout with a single number rather than with a range, the returned Layout as N-1 dimensions. Thus, the Layout being sliced must have N>1 dimensions. Non-Member functions \u00b6 equality operator== \u00b6 signature \u00b6 template < size_t M > bool operator == ( const Layout < M >& l1 , const Layout < M >& l2 ); brief \u00b6 Comparison operator that verifies the equality of Layout objects of the same order M . template parameter \u00b6 M : the order of the two Layouts to be compared. parameter \u00b6 l1 : first Layout object of the comparison. l2 : second Layout object of the comparison. return \u00b6 true if the two Layouts are equal, false otherwise inequality operator!= \u00b6 signature \u00b6 template < size_t M > bool operator != ( const Layout < M >& l1 , const Layout < M >& l2 ); brief \u00b6 Comparison operator that verifies the inequality of Layout objects of the same order M . template parameter \u00b6 M : the order of the two Layouts to be compared. parameter \u00b6 l1 : first Layout object of the comparison. l2 : second Layout object of the comparison. return \u00b6 true if the two Layouts are unequal, false otherwise","title":"Layout"},{"location":"api/Layout.html#layout-class","text":"Defined in header holor/layout.h , within the namespace holor . template < size_t N > requires ( N > 0 ) class Layout This class implements the mapping between the indices a Holor container and the locations in the memory where the elements are stored. It uses the idea of generalized layouts from the standard library, i.e., it is based on the fact that the elements of a Holor or HolorRef are stored as a 1D data sequence following a row-major representation. A layout contains three main pieces of attributes: offset : the offset in the contiguous memory of the first element indexed by the layout. lengths : the numbers of elements along every dimension of the layout. strides : the distances in the 1D memory sequence between successive elements in individual dimensions of the layout. Note For a Layout with N dimensions, both the length array and the stride array must be size N . A Layout supports two fundamental operations: Indexing : this operation provides a map from the coordinates in the container to the index in memory of the selected element; Slicing : this operation allows to select a subset of elements from a container by computing a new Layout that provides the needed information to index them.","title":"Layout class"},{"location":"api/Layout.html#template-parameters","text":"Name Description N number of dimensions in the layout. It must be N>0","title":"Template parameters"},{"location":"api/Layout.html#member-types-and-aliases","text":"Name Description order static constexpr member equal to N","title":"Member types and aliases"},{"location":"api/Layout.html#public-member-functions","text":"","title":"Public Member functions"},{"location":"api/Layout.html#constructors","text":"","title":"Constructors"},{"location":"api/Layout.html#assignments","text":"","title":"Assignments"},{"location":"api/Layout.html#getset-functions","text":"","title":"Get/Set functions"},{"location":"api/Layout.html#dimensions","text":"","title":"dimensions"},{"location":"api/Layout.html#size","text":"","title":"size"},{"location":"api/Layout.html#offset","text":"","title":"offset"},{"location":"api/Layout.html#lengths","text":"","title":"lengths"},{"location":"api/Layout.html#set_lengths","text":"","title":"set_lengths"},{"location":"api/Layout.html#length","text":"","title":"length"},{"location":"api/Layout.html#set_length","text":"","title":"set_length"},{"location":"api/Layout.html#strides","text":"","title":"strides"},{"location":"api/Layout.html#stride","text":"","title":"stride"},{"location":"api/Layout.html#indexing-functions","text":"","title":"Indexing functions"},{"location":"api/Layout.html#operator","text":"","title":"operator()"},{"location":"api/Layout.html#slicing-functions","text":"","title":"Slicing functions"},{"location":"api/Layout.html#operator_1","text":"","title":"operator()"},{"location":"api/Layout.html#slice_unreduced","text":"","title":"slice_unreduced"},{"location":"api/Layout.html#slice_dimension","text":"","title":"slice_dimension"},{"location":"api/Layout.html#non-member-functions","text":"","title":"Non-Member functions"},{"location":"api/Layout.html#equality-operator","text":"","title":"equality operator=="},{"location":"api/Layout.html#inequality-operator","text":"","title":"inequality operator!="},{"location":"getting_started/index.html","text":"Getting Started \u00b6 HolorLib is a header only library that is written using C++20 features. Experimenting with C++20 was actually one of the reasons for the creation of this library, as an exercise. As it stands, C++20 is not yet fully supported by compilers and a few of its new features are not yet readily available. I did not perform a thorough test to verify compilers compatibility and I have only used clang++-12 , so for now please refer to the compiler support list here . Be mindful that, as for all early releases of new compilers, even though they report supporting certain C++20 features, they may have some bugs. For example, I failed to compile the examples shipped with this library using g++-10 due to a compiler bug when using concepts in partial template specializations. Next steps: Install the library Build optional components","title":"Getting Started"},{"location":"getting_started/index.html#getting-started","text":"HolorLib is a header only library that is written using C++20 features. Experimenting with C++20 was actually one of the reasons for the creation of this library, as an exercise. As it stands, C++20 is not yet fully supported by compilers and a few of its new features are not yet readily available. I did not perform a thorough test to verify compilers compatibility and I have only used clang++-12 , so for now please refer to the compiler support list here . Be mindful that, as for all early releases of new compilers, even though they report supporting certain C++20 features, they may have some bugs. For example, I failed to compile the examples shipped with this library using g++-10 due to a compiler bug when using concepts in partial template specializations. Next steps: Install the library Build optional components","title":"Getting Started"},{"location":"getting_started/install.html","text":"Installation \u00b6 Method 1. Installation with CMake (Recommended) \u00b6 Requirements CMake 3.12 or above HolorLib is shipped as a CMake package, which allows it to be easily installed and used by other CMake projects. This process can be performed explicitly or using the installation script packaged with the library. explicit 1 2 3 4 5 6 git clone TBD <destination_path> cd <destination path>/Holor mkdir build && cd build cmake .. - [ options ] ccmake . #optional, to check and possibly modify the CMake options cmake --install . script 1 2 3 git clone TBD <destination_path> cd <destination path>/Holor ./holor.sh install Note Depending on the destination where the header files will be copied, the installation (line 6 in the manual instructions) may require superuser privileges. In that case call it with sudo . There are a few CMake options that can be passed to customize the manual CMake installation: CMake Option Description Possible Values Default CMAKE_INSTALL_PREFIX location where the header files will be copied a path \\user\\local\\install DEFINE_HOLOR_ASSERT_LEVEL control HolorLibs exceptions-throwing dynamic checks AssertionLevel::release , AssertionLevel::no_checks , AssertionLevel::debug AssertionLevel::release Example For a manual installation to a different path (e.g. /home/user/my_project ), line 4 in the manual instructions becomes cmake .. -DCMAKE_INSTALL_PREFIX = /home/user/my_project Such options are not available in the installation script , which uses the default values. Tip We advise to use the default value for DEFINE_HOLOR_ASSERT_LEVEL . How to use it in a project \u00b6 When HolorLib is installed using CMake, it can be easily imported in other CMake projects. find_package ( Holor REQUIRED ) set ( CMAKE_CXX_STANDARD 20 ) set ( CMAKE_CXX_STANDARD_REQUIRED ON ) add_executable ( my_program my_program.cpp ) #example of an executable target_link_libraries ( my_program PUBLIC Holor::Holor ) Within the the file my_program.cpp , the HolorLib C++ API is accessible with a simple include #include <holor/holor_full.h> Deleting the installation \u00b6 During the installation with these method, CMake create an install_manifest.txt file in the build folder which contains the information where the files have been installed and allows to easily remove them. explicit cd <build directory> make uninstall script ./holor.sh clean Tip It may be necessary to call the command make uninstall with superuser privileges (using sudo ) depending on how and where the files were installed. If install_manifest.txt was deleted, the installed files must be manually removed by the user. Method 2. Installation without CMake \u00b6 HolorLib can also be used by simply copying the header files into a project. git clone TBD <destination_path> cd <destination path> cp include <project_path> How to use it in a project \u00b6 Once the header files are copied in the C++ project, HolorLib API is accessible with a simple include #include \"<path_to_local_include>/holor/holor_full.h\" Deleting the installation \u00b6 Since there is no installation, only the header files copied in the project need to be removed.","title":"Installation"},{"location":"getting_started/install.html#installation","text":"","title":"Installation"},{"location":"getting_started/install.html#method-1-installation-with-cmake-recommended","text":"Requirements CMake 3.12 or above HolorLib is shipped as a CMake package, which allows it to be easily installed and used by other CMake projects. This process can be performed explicitly or using the installation script packaged with the library. explicit 1 2 3 4 5 6 git clone TBD <destination_path> cd <destination path>/Holor mkdir build && cd build cmake .. - [ options ] ccmake . #optional, to check and possibly modify the CMake options cmake --install . script 1 2 3 git clone TBD <destination_path> cd <destination path>/Holor ./holor.sh install Note Depending on the destination where the header files will be copied, the installation (line 6 in the manual instructions) may require superuser privileges. In that case call it with sudo . There are a few CMake options that can be passed to customize the manual CMake installation: CMake Option Description Possible Values Default CMAKE_INSTALL_PREFIX location where the header files will be copied a path \\user\\local\\install DEFINE_HOLOR_ASSERT_LEVEL control HolorLibs exceptions-throwing dynamic checks AssertionLevel::release , AssertionLevel::no_checks , AssertionLevel::debug AssertionLevel::release Example For a manual installation to a different path (e.g. /home/user/my_project ), line 4 in the manual instructions becomes cmake .. -DCMAKE_INSTALL_PREFIX = /home/user/my_project Such options are not available in the installation script , which uses the default values. Tip We advise to use the default value for DEFINE_HOLOR_ASSERT_LEVEL .","title":"Method 1. Installation with CMake (Recommended)"},{"location":"getting_started/install.html#how-to-use-it-in-a-project","text":"When HolorLib is installed using CMake, it can be easily imported in other CMake projects. find_package ( Holor REQUIRED ) set ( CMAKE_CXX_STANDARD 20 ) set ( CMAKE_CXX_STANDARD_REQUIRED ON ) add_executable ( my_program my_program.cpp ) #example of an executable target_link_libraries ( my_program PUBLIC Holor::Holor ) Within the the file my_program.cpp , the HolorLib C++ API is accessible with a simple include #include <holor/holor_full.h>","title":"How to use it in a project"},{"location":"getting_started/install.html#deleting-the-installation","text":"During the installation with these method, CMake create an install_manifest.txt file in the build folder which contains the information where the files have been installed and allows to easily remove them. explicit cd <build directory> make uninstall script ./holor.sh clean Tip It may be necessary to call the command make uninstall with superuser privileges (using sudo ) depending on how and where the files were installed. If install_manifest.txt was deleted, the installed files must be manually removed by the user.","title":"Deleting the installation"},{"location":"getting_started/install.html#method-2-installation-without-cmake","text":"HolorLib can also be used by simply copying the header files into a project. git clone TBD <destination_path> cd <destination path> cp include <project_path>","title":"Method 2. Installation without CMake"},{"location":"getting_started/install.html#how-to-use-it-in-a-project_1","text":"Once the header files are copied in the C++ project, HolorLib API is accessible with a simple include #include \"<path_to_local_include>/holor/holor_full.h\"","title":"How to use it in a project"},{"location":"getting_started/install.html#deleting-the-installation_1","text":"Since there is no installation, only the header files copied in the project need to be removed.","title":"Deleting the installation"},{"location":"getting_started/optional.html","text":"Optional modules \u00b6 HolorLib contains some optional modules that can be built after the installation. Examples \u00b6 Some examples that demonstrate few uses of the library, such as how to construct and slice Holors. The examples can be compiled using the following instructions from the root folder. excplicit cmake cd build cmake .. -DHOLOR_BUILD_EXAMPLES = ON -DCMAKE_BUILD_TYPE = Release [ -DCMAKE_CXX_COMPILER = ... ] make script ./holor.sh build_examples [ --compiler ... ] The compilation of the examples is enabled by setting the cmake option -DHOLOR_BUILD_EXAMPLES=ON . Optionally, one can specify the compiler to be used with the cmake option -DCMAKE_CXX_COMPILER , for example if the default system compiler does not support C++20. The examples can be compiled using the script holor.sh . Optionally, one can specify the compiler to be used with argument --compiler , for example if the default system compiler does not support C++20. The compiled binaries are located in the directory build/bin . Tests \u00b6 Some tests to verify the correct behavior of the library. The tests can be compiled using the following instructions from the root folder. Requirements The tests require gtest , to be used in conjunction with CMake. We recommend checking the instructions on the gtest page. For a quick setup, go to the directory where you want to download the gtest repository and follow these instructions git clone https://github.com/google/googletest.git cd googletest mkdir build cd build cmake .. make sudo make install excplicit cmake cd build cmake .. -DHOLOR_BUILD_TESTS = ON -DCMAKE_BUILD_TYPE = Release [ -DCMAKE_CXX_COMPILER = ... ] make script ./holor.sh build_tests [ --compiler ... ] The compilation of the tests is enabled by setting the cmake option -DHOLOR_BUILD_TESTS=ON . Optionally, one can specify the compiler to be used with the cmake option -DCMAKE_CXX_COMPILER , for example if the default system compiler does not support C++20. The tests can be compiled using the script holor.sh . Optionally, one can specify the compiler to be used with argument --compiler , for example if the default system compiler does not support C++20. The compiled binaries are located in the directory build/bin . Benchmarks \u00b6 Some benchmarks to evalaute the performance of the Holor containers. The benchmarks can be compiled using the following instructions from the root folder. Requirements The tests require google benchmark , to be used in conjunction with CMake. We recommend checking the instructions on the benchmark page. For a quick setup, go to the directory where you want to download the repository and follow these instructions git clone https://github.com/google/benchmark.git cd benchmark cmake -E make_directory \"build\" cmake -E chdir \"build\" cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES = on -DCMAKE_BUILD_TYPE = Release ../ cmake -DCMAKE_BUILD_TYPE = Release -S . -B \"build\" cmake --build \"build\" --config Release cd build sudo make install explicit cd build cmake .. -DHOLOR_BUILD_BENCHMARKS = ON -DCMAKE_BUILD_TYPE = Release [ -DCMAKE_CXX_COMPILER = ... ] make script `` bash ./holor.sh build_benchmarks [--compiler ...] ``` The compilation of the benchmarks is enabled by setting the cmake option -DHOLOR_BUILD_BENCHMARKS=ON . Optionally, one can specify the compiler to be used with the cmake option -DCMAKE_CXX_COMPILER , for example if the default system compiler does not support C++20. The benchmarks can be compiled using the script holor.sh . Optionally, one can specify the compiler to be used with argument --compiler , for example if the default system compiler does not support C++20. The compiled binaries are located in the directory build/bin . Documentation \u00b6 This very same documentation can be built locally to be accessed offline. Requirements The documentation is built using Material for MkDocs 7.3.0 or superior. We recommend to install it using pip pip install mkdocs-material The documentation can be built using the following command from the root folder mkdocs build The documentation, is generated in html format in the site folder. To consult it, open the index.html file in a web browser.","title":"Optional modules"},{"location":"getting_started/optional.html#optional-modules","text":"HolorLib contains some optional modules that can be built after the installation.","title":"Optional modules"},{"location":"getting_started/optional.html#examples","text":"Some examples that demonstrate few uses of the library, such as how to construct and slice Holors. The examples can be compiled using the following instructions from the root folder. excplicit cmake cd build cmake .. -DHOLOR_BUILD_EXAMPLES = ON -DCMAKE_BUILD_TYPE = Release [ -DCMAKE_CXX_COMPILER = ... ] make script ./holor.sh build_examples [ --compiler ... ] The compilation of the examples is enabled by setting the cmake option -DHOLOR_BUILD_EXAMPLES=ON . Optionally, one can specify the compiler to be used with the cmake option -DCMAKE_CXX_COMPILER , for example if the default system compiler does not support C++20. The examples can be compiled using the script holor.sh . Optionally, one can specify the compiler to be used with argument --compiler , for example if the default system compiler does not support C++20. The compiled binaries are located in the directory build/bin .","title":"Examples"},{"location":"getting_started/optional.html#tests","text":"Some tests to verify the correct behavior of the library. The tests can be compiled using the following instructions from the root folder. Requirements The tests require gtest , to be used in conjunction with CMake. We recommend checking the instructions on the gtest page. For a quick setup, go to the directory where you want to download the gtest repository and follow these instructions git clone https://github.com/google/googletest.git cd googletest mkdir build cd build cmake .. make sudo make install excplicit cmake cd build cmake .. -DHOLOR_BUILD_TESTS = ON -DCMAKE_BUILD_TYPE = Release [ -DCMAKE_CXX_COMPILER = ... ] make script ./holor.sh build_tests [ --compiler ... ] The compilation of the tests is enabled by setting the cmake option -DHOLOR_BUILD_TESTS=ON . Optionally, one can specify the compiler to be used with the cmake option -DCMAKE_CXX_COMPILER , for example if the default system compiler does not support C++20. The tests can be compiled using the script holor.sh . Optionally, one can specify the compiler to be used with argument --compiler , for example if the default system compiler does not support C++20. The compiled binaries are located in the directory build/bin .","title":"Tests"},{"location":"getting_started/optional.html#benchmarks","text":"Some benchmarks to evalaute the performance of the Holor containers. The benchmarks can be compiled using the following instructions from the root folder. Requirements The tests require google benchmark , to be used in conjunction with CMake. We recommend checking the instructions on the benchmark page. For a quick setup, go to the directory where you want to download the repository and follow these instructions git clone https://github.com/google/benchmark.git cd benchmark cmake -E make_directory \"build\" cmake -E chdir \"build\" cmake -DBENCHMARK_DOWNLOAD_DEPENDENCIES = on -DCMAKE_BUILD_TYPE = Release ../ cmake -DCMAKE_BUILD_TYPE = Release -S . -B \"build\" cmake --build \"build\" --config Release cd build sudo make install explicit cd build cmake .. -DHOLOR_BUILD_BENCHMARKS = ON -DCMAKE_BUILD_TYPE = Release [ -DCMAKE_CXX_COMPILER = ... ] make script `` bash ./holor.sh build_benchmarks [--compiler ...] ``` The compilation of the benchmarks is enabled by setting the cmake option -DHOLOR_BUILD_BENCHMARKS=ON . Optionally, one can specify the compiler to be used with the cmake option -DCMAKE_CXX_COMPILER , for example if the default system compiler does not support C++20. The benchmarks can be compiled using the script holor.sh . Optionally, one can specify the compiler to be used with argument --compiler , for example if the default system compiler does not support C++20. The compiled binaries are located in the directory build/bin .","title":"Benchmarks"},{"location":"getting_started/optional.html#documentation","text":"This very same documentation can be built locally to be accessed offline. Requirements The documentation is built using Material for MkDocs 7.3.0 or superior. We recommend to install it using pip pip install mkdocs-material The documentation can be built using the following command from the root folder mkdocs build The documentation, is generated in html format in the site folder. To consult it, open the index.html file in a web browser.","title":"Documentation"},{"location":"tutorials/index.html","text":"Tutorials \u00b6 This section presents some basic examples of use of the library. New users are encouraged to read through all the tutorials; it will only taky a few minutes. For further tutorials check the examples Tutorials: Layout basics Holor basics HolorRef basics Indexing and slicing Iterators","title":"Tutorials"},{"location":"tutorials/index.html#tutorials","text":"This section presents some basic examples of use of the library. New users are encouraged to read through all the tutorials; it will only taky a few minutes. For further tutorials check the examples Tutorials: Layout basics Holor basics HolorRef basics Indexing and slicing Iterators","title":"Tutorials"},{"location":"tutorials/holor.html","text":"Holor Basics \u00b6 Construction and assignment of Holors \u00b6 A Holor container can be created from a nested list of elements #include <holor/holor_full.h> using namespace holor ; Holor < int , 2 > my_holor {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; /* This creates a 2D matrix container |1 2 3| |4 5 6| */ std :: cout << my_holor << std : endln ; //prints the elements in my_holor, i.e., ((1, 2, 3), (4, 5, 6)). A Holor container can be created or assigned from another Holor or HolorRef #include <holor/holor_full.h> using namespace holor ; Holor < int , 2 > my_holor {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; Holor < int , 2 > my_holor_2 = my_holor ; Holor < int , 2 > my_holor_3 { my_holor }; std :: cout << my_holor_2 << std : endln ; //prints the elements in my_holor_2, i.e., ((1, 2, 3), (4, 5, 6)). std :: cout << my_holor_3 << std : endln ; //prints the elements in my_holor_3, i.e., ((1, 2, 3), (4, 5, 6)). A Holor container can be created by specifying the length of its dimensions with a standard container. In this case its elements are not initialized. #include <holor/holor_full.h> using namespace holor ; std :: vector < int > my_lengths1 { 3 , 6 , 2 }; Holor < float , 3 > empty_holor1 ( my_lengths1 ); std :: array < int , 4 > my_lengths2 { 3 , 1 , 6 , 2 }; Holor < float , 4 > empty_holor2 ( my_lengths2 ); An empty holor can be constructed without specifying its elements or dimensions. #include <holor/holor_full.h> using namespace holor ; struct my_object { float a ; int b ; double c ; }; Holor < my_object , 3 > empty_holor ; std :: cout << \" \\033 [32m Holor<my_object, 3> empty_holor_03; \\033 [0m (my_object is a generic type, for example a struct) \\n \" ; std :: cout << \" The lenghts of \\033 [1m empty_holor_03 \\033 [0m along its dimensions are: [\" ; for ( auto cnt = 0 ; cnt < 3 ; cnt ++ ){ std :: cout << \" \" << empty_holor_03 . lengths ( cnt ); } std :: cout << \" ] \\n\\n \" ; Resizing a Holor \u00b6 A Holor has a fixed number of dimensions, but the number of elements along each dimension can be changed. This is useful when the number of elements needs to be modified over time, or to create an empty container and resize it later. #include <Holor/holor/holor_full.h> using namespace holor ; Holor < float , 2 > hf ; //An empty container with 2 dimensions hf . set_lengths ( 3 , 2 ); //Now hf is a 3x2 container std :: ranges :: fill ( hf , 1.2 ); //All the elements of hf are set to the value 1.2 hf . set_lengts ( 0 , 2 ); //This operation modifies only the first length and sets it to 2. Now hf is a 2x2 container Using Holor's get functions \u00b6 The Holor class has few member functions that can be used to retrieve information regarding the container or to gain direct access to its memory. #include <holor/holor_full.h> using namespace holor ; Holor < float , 2 > hf {{ 1.1 , -0.3 }, { 7.7 , 9.12 }}; //A 2-by-2 container of floats auto hf_layout = hf . layout (); //get the layout of the Holor container auto hf_lengths = hf . lengths (); // get the lengths of the Holor container as a std::array auto hf_size = hf . size (); //get the number of elements in the container, i.e. 4 auto hf_data_vector = hf . data_vector (); // get a copy of the vector that internally stores the data auto hf_data = hf . data (); // get a pointer to the memory where the data is stored & ( hf_data () + 1 ) = 0.3 ; // we are manually changing the element at coordinates (0,1) in the container from -0.3 to 0.3","title":"Holor basics"},{"location":"tutorials/holor.html#holor-basics","text":"","title":"Holor Basics"},{"location":"tutorials/holor.html#construction-and-assignment-of-holors","text":"A Holor container can be created from a nested list of elements #include <holor/holor_full.h> using namespace holor ; Holor < int , 2 > my_holor {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; /* This creates a 2D matrix container |1 2 3| |4 5 6| */ std :: cout << my_holor << std : endln ; //prints the elements in my_holor, i.e., ((1, 2, 3), (4, 5, 6)). A Holor container can be created or assigned from another Holor or HolorRef #include <holor/holor_full.h> using namespace holor ; Holor < int , 2 > my_holor {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; Holor < int , 2 > my_holor_2 = my_holor ; Holor < int , 2 > my_holor_3 { my_holor }; std :: cout << my_holor_2 << std : endln ; //prints the elements in my_holor_2, i.e., ((1, 2, 3), (4, 5, 6)). std :: cout << my_holor_3 << std : endln ; //prints the elements in my_holor_3, i.e., ((1, 2, 3), (4, 5, 6)). A Holor container can be created by specifying the length of its dimensions with a standard container. In this case its elements are not initialized. #include <holor/holor_full.h> using namespace holor ; std :: vector < int > my_lengths1 { 3 , 6 , 2 }; Holor < float , 3 > empty_holor1 ( my_lengths1 ); std :: array < int , 4 > my_lengths2 { 3 , 1 , 6 , 2 }; Holor < float , 4 > empty_holor2 ( my_lengths2 ); An empty holor can be constructed without specifying its elements or dimensions. #include <holor/holor_full.h> using namespace holor ; struct my_object { float a ; int b ; double c ; }; Holor < my_object , 3 > empty_holor ; std :: cout << \" \\033 [32m Holor<my_object, 3> empty_holor_03; \\033 [0m (my_object is a generic type, for example a struct) \\n \" ; std :: cout << \" The lenghts of \\033 [1m empty_holor_03 \\033 [0m along its dimensions are: [\" ; for ( auto cnt = 0 ; cnt < 3 ; cnt ++ ){ std :: cout << \" \" << empty_holor_03 . lengths ( cnt ); } std :: cout << \" ] \\n\\n \" ;","title":"Construction and assignment of Holors"},{"location":"tutorials/holor.html#resizing-a-holor","text":"A Holor has a fixed number of dimensions, but the number of elements along each dimension can be changed. This is useful when the number of elements needs to be modified over time, or to create an empty container and resize it later. #include <Holor/holor/holor_full.h> using namespace holor ; Holor < float , 2 > hf ; //An empty container with 2 dimensions hf . set_lengths ( 3 , 2 ); //Now hf is a 3x2 container std :: ranges :: fill ( hf , 1.2 ); //All the elements of hf are set to the value 1.2 hf . set_lengts ( 0 , 2 ); //This operation modifies only the first length and sets it to 2. Now hf is a 2x2 container","title":"Resizing a Holor"},{"location":"tutorials/holor.html#using-holors-get-functions","text":"The Holor class has few member functions that can be used to retrieve information regarding the container or to gain direct access to its memory. #include <holor/holor_full.h> using namespace holor ; Holor < float , 2 > hf {{ 1.1 , -0.3 }, { 7.7 , 9.12 }}; //A 2-by-2 container of floats auto hf_layout = hf . layout (); //get the layout of the Holor container auto hf_lengths = hf . lengths (); // get the lengths of the Holor container as a std::array auto hf_size = hf . size (); //get the number of elements in the container, i.e. 4 auto hf_data_vector = hf . data_vector (); // get a copy of the vector that internally stores the data auto hf_data = hf . data (); // get a pointer to the memory where the data is stored & ( hf_data () + 1 ) = 0.3 ; // we are manually changing the element at coordinates (0,1) in the container from -0.3 to 0.3","title":"Using Holor's get functions"},{"location":"tutorials/holorref.html","text":"HolorRef Basics \u00b6 Construction and assignment of HolorRefs \u00b6 Unlike Holor containers, HolorRef containers do not own the memory where the elements are stored. The purpose of HolorRef is to provide a Holor-like view over data that is owned by other objects. Therefore, HolorRef containers need to be provided with a pointer to the data in order to be constructed. #include <holor/holor_full.h> using namespace holor ; std :: vector < int > my_sequence { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; HolorRef < int , 2 > matrix_view ( my_sequence . data (), Layout < 2 > { 2 , 5 }); //constructor passing a layout HolorRef < int , 2 > matrix_view2 ( my_sequence . data (), std :: vector < int > { 2 , 5 }); //same result as before, but passing a dynamic-size container of lengths HolorRef < int , 2 > matrix_view2 ( my_sequence . data (), std :: array < int , 2 > { 2 , 5 }); //same result as before, but passing a fixed-size container of lengths /* All these constructors create a 2-by-2 HolorRef container shaped as |1 2 3 4 5 | |6 7 8 9 10| */ //matrix_view does not own its elements. Changing them changes the elements in my sequence matrix_view ( 1 , 0 ) = 99 ; //now we have changed the entry at coordinates (0,1) from 6 to 99 for ( auto && x : my_sequence ){ std :: cout << x << \" \" ; } std :: cout << std :: endln ; //this prints the sequence 1 2 3 4 5 99 7 8 9 10 A HolorRef container can be created or assigned from another HolorRef #include <holor/holor_full.h> using namespace holor ; std :: vector < int > my_sequence { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; HolorRef < int , 2 > matrix_view ( my_sequence . data (), Layout < 2 > { 2 , 5 }); //constructor passing a layout HolorRef < int , 2 > href_assign = matrix_view ; Holor < int , 2 > href_copy { matrix_view }; Using HolorRef's get functions \u00b6 The HolorRef class has few member functions that can be used to retrieve information regarding the container or to gain direct access to its memory. #include <holor/holor_full.h> using namespace holor ; std :: array < float , 4 > my_data { 1.1 , -0.3 , 7.7 , 9.12 }; HolorRef < float , 2 > href ( my_data . data (), Layout < 2 > { 2 , 2 }); //create a view of the data as a 2-by-2 matrix auto href_layout = href . layout (); //get the layout of the Holor container auto href_lengths = href . lengths (); // get the lengths of the Holor container as a std::array auto href_size = href . size (); //get the number of elements in the container, i.e. 4 auto href_data = href . data (); // get a pointer to the memory where the data is stored & ( href_data () + 1 ) = 0.3 ; // we are manually changing the element at coordinates (0,1) in the container from -0.3 to 0.3 for ( auto && x : my_data ){ std :: cout << x << \" \" ; } std :: cout << std :: endln ; //this prints the sequence 1.1 0.3 7.7 9.12","title":"HolorRef basics"},{"location":"tutorials/holorref.html#holorref-basics","text":"","title":"HolorRef Basics"},{"location":"tutorials/holorref.html#construction-and-assignment-of-holorrefs","text":"Unlike Holor containers, HolorRef containers do not own the memory where the elements are stored. The purpose of HolorRef is to provide a Holor-like view over data that is owned by other objects. Therefore, HolorRef containers need to be provided with a pointer to the data in order to be constructed. #include <holor/holor_full.h> using namespace holor ; std :: vector < int > my_sequence { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; HolorRef < int , 2 > matrix_view ( my_sequence . data (), Layout < 2 > { 2 , 5 }); //constructor passing a layout HolorRef < int , 2 > matrix_view2 ( my_sequence . data (), std :: vector < int > { 2 , 5 }); //same result as before, but passing a dynamic-size container of lengths HolorRef < int , 2 > matrix_view2 ( my_sequence . data (), std :: array < int , 2 > { 2 , 5 }); //same result as before, but passing a fixed-size container of lengths /* All these constructors create a 2-by-2 HolorRef container shaped as |1 2 3 4 5 | |6 7 8 9 10| */ //matrix_view does not own its elements. Changing them changes the elements in my sequence matrix_view ( 1 , 0 ) = 99 ; //now we have changed the entry at coordinates (0,1) from 6 to 99 for ( auto && x : my_sequence ){ std :: cout << x << \" \" ; } std :: cout << std :: endln ; //this prints the sequence 1 2 3 4 5 99 7 8 9 10 A HolorRef container can be created or assigned from another HolorRef #include <holor/holor_full.h> using namespace holor ; std :: vector < int > my_sequence { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 }; HolorRef < int , 2 > matrix_view ( my_sequence . data (), Layout < 2 > { 2 , 5 }); //constructor passing a layout HolorRef < int , 2 > href_assign = matrix_view ; Holor < int , 2 > href_copy { matrix_view };","title":"Construction and assignment of HolorRefs"},{"location":"tutorials/holorref.html#using-holorrefs-get-functions","text":"The HolorRef class has few member functions that can be used to retrieve information regarding the container or to gain direct access to its memory. #include <holor/holor_full.h> using namespace holor ; std :: array < float , 4 > my_data { 1.1 , -0.3 , 7.7 , 9.12 }; HolorRef < float , 2 > href ( my_data . data (), Layout < 2 > { 2 , 2 }); //create a view of the data as a 2-by-2 matrix auto href_layout = href . layout (); //get the layout of the Holor container auto href_lengths = href . lengths (); // get the lengths of the Holor container as a std::array auto href_size = href . size (); //get the number of elements in the container, i.e. 4 auto href_data = href . data (); // get a pointer to the memory where the data is stored & ( href_data () + 1 ) = 0.3 ; // we are manually changing the element at coordinates (0,1) in the container from -0.3 to 0.3 for ( auto && x : my_data ){ std :: cout << x << \" \" ; } std :: cout << std :: endln ; //this prints the sequence 1.1 0.3 7.7 9.12","title":"Using HolorRef's get functions"},{"location":"tutorials/indexing_slicing.html","text":"Indexing and Slicing \u00b6 Indexing \u00b6 Holor and HolorRef containers allow to access specific elements by referring to them using a classic index notation. #include <holor/holor_full.h> using namespace holor ; Holor < int , 3 > tensor {{{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, {{ 7 , 8 , 9 }, { 10 , 11 , 12 }}}; auto n = tensor ( 1 , 0 , 2 ); //n has the value 9 tensor ( 0 , 0 , 0 ) = 1000 ; //now tensor has elements {{{1000, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}} //the same functionality is available for HolorRef containers std :: vector < int > vec { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; HolorRef < int , 3 > tensor_ref ( vec . data (), Layout < 3 > { 2 , 2 , 3 }); auto m = tensor_ref ( 1 , 0 , 2 ); //m has the value 9 tensor_ref ( 0 , 0 , 0 ) = 1000 ; //now tensor has elements {{{1000, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}} std :: cout << vec [ 0 ] << \" \\n \" ; //this prints 1000 Slicing \u00b6 Holor and HolorRef can be sliced using the operator() similarly to the indexing, but passing ranges of values for at leas a coordinate. #include <holor/holor_full.h> using namespace holor ; Holor < int , 3 > tensor {{{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, {{ 7 , 8 , 9 }, { 10 , 11 , 12 }}, {{ 13 , 14 , 15 }, { 16 , 17 , 18 }}}; //tensor is a 3 x 2 x 3 matrix // Let's take a 2D slice corresponding to the first two rows, second column and last two aisles auto my_slice = tensor ( range ( 0 , 1 ), 1 , range ( 1 , 2 )); //my_slice is a HolorRef view over the 2D slice of elements std :: cout << my_slice << \" \\n \" ; //this prints ((5, 6), (11, 12)) // Since the sice is a HolorRef, modifying its elements modifies the original holor my_slice ( 1 , 0 ) = 1000 ; std :: cout << tensor << \" \\n \" ; //this now prints (((1, 2, 3), (4, 5, 6)), ((7, 8, 9), (10, 1000, 12)), ((13, 14, 15), (16, 17, 18))) //Since a slice is a HolorRef, we can furhter slice it auto my_slice2 = my_slice ( 1 , range ( 0 , 1 )); //my_slice2 is a 1D HolorRef containing the elements (1000, 12) HolorLib also provides some functions to get a slice over a specific dimension of the containers (both with Holor and HolorRef) #include <holor/holor_full.h> using namespace holor ; Holor < int , 3 > tensor {{{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, {{ 7 , 8 , 9 }, { 10 , 11 , 12 }}, {{ 13 , 14 , 15 }, { 16 , 17 , 18 }}}; auto row0 = tensor . row ( 0 ); //slices the first row, i.e., ((1, 2, 3), (4, 5, 6)) auto col1 = tensor . col ( 1 ); //slices the second column, i.e., ((4, 5, 6), (10, 11, 12), (16, 17, 18)) auto my_slice = tensor . slice < 3 > ( 2 ) // slices the third aisle (third dimension), i.e., ((3, 6), (9, 12), (15, 18))","title":"Indexing and slicing"},{"location":"tutorials/indexing_slicing.html#indexing-and-slicing","text":"","title":"Indexing and Slicing"},{"location":"tutorials/indexing_slicing.html#indexing","text":"Holor and HolorRef containers allow to access specific elements by referring to them using a classic index notation. #include <holor/holor_full.h> using namespace holor ; Holor < int , 3 > tensor {{{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, {{ 7 , 8 , 9 }, { 10 , 11 , 12 }}}; auto n = tensor ( 1 , 0 , 2 ); //n has the value 9 tensor ( 0 , 0 , 0 ) = 1000 ; //now tensor has elements {{{1000, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}} //the same functionality is available for HolorRef containers std :: vector < int > vec { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 }; HolorRef < int , 3 > tensor_ref ( vec . data (), Layout < 3 > { 2 , 2 , 3 }); auto m = tensor_ref ( 1 , 0 , 2 ); //m has the value 9 tensor_ref ( 0 , 0 , 0 ) = 1000 ; //now tensor has elements {{{1000, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}} std :: cout << vec [ 0 ] << \" \\n \" ; //this prints 1000","title":"Indexing"},{"location":"tutorials/indexing_slicing.html#slicing","text":"Holor and HolorRef can be sliced using the operator() similarly to the indexing, but passing ranges of values for at leas a coordinate. #include <holor/holor_full.h> using namespace holor ; Holor < int , 3 > tensor {{{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, {{ 7 , 8 , 9 }, { 10 , 11 , 12 }}, {{ 13 , 14 , 15 }, { 16 , 17 , 18 }}}; //tensor is a 3 x 2 x 3 matrix // Let's take a 2D slice corresponding to the first two rows, second column and last two aisles auto my_slice = tensor ( range ( 0 , 1 ), 1 , range ( 1 , 2 )); //my_slice is a HolorRef view over the 2D slice of elements std :: cout << my_slice << \" \\n \" ; //this prints ((5, 6), (11, 12)) // Since the sice is a HolorRef, modifying its elements modifies the original holor my_slice ( 1 , 0 ) = 1000 ; std :: cout << tensor << \" \\n \" ; //this now prints (((1, 2, 3), (4, 5, 6)), ((7, 8, 9), (10, 1000, 12)), ((13, 14, 15), (16, 17, 18))) //Since a slice is a HolorRef, we can furhter slice it auto my_slice2 = my_slice ( 1 , range ( 0 , 1 )); //my_slice2 is a 1D HolorRef containing the elements (1000, 12) HolorLib also provides some functions to get a slice over a specific dimension of the containers (both with Holor and HolorRef) #include <holor/holor_full.h> using namespace holor ; Holor < int , 3 > tensor {{{ 1 , 2 , 3 }, { 4 , 5 , 6 }}, {{ 7 , 8 , 9 }, { 10 , 11 , 12 }}, {{ 13 , 14 , 15 }, { 16 , 17 , 18 }}}; auto row0 = tensor . row ( 0 ); //slices the first row, i.e., ((1, 2, 3), (4, 5, 6)) auto col1 = tensor . col ( 1 ); //slices the second column, i.e., ((4, 5, 6), (10, 11, 12), (16, 17, 18)) auto my_slice = tensor . slice < 3 > ( 2 ) // slices the third aisle (third dimension), i.e., ((3, 6), (9, 12), (15, 18))","title":"Slicing"},{"location":"tutorials/iterators.html","text":"Iterators \u00b6 Holor and HolorRef containers provide iterators that can be used in conjunction with standard algorithm functions, e.g. to copy values to the containers #include <holor/holor_full.h> #include <algorithm> using namespace holor ; Holor < int , 2 > matrix {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; std :: transform ( matrix . begin (), matrix . end (), matrix . begin (), []( int n ) -> int { return c * 10 ; }); //multiplies all elements in matrix by 10. Matrix now is ((10, 20, 30), (40, 50, 60)) Holor < int , 1 > vec { 111 , 222 }; auto col1 = matrix . col ( 1 ); std :: copy ( vec . begin (), vec . end (), matrix . rbegin ()); //copies vec in reverse on the second column of matrix. Matrix now is ((10, 222, 30), (40, 111, 60))","title":"Iterators"},{"location":"tutorials/iterators.html#iterators","text":"Holor and HolorRef containers provide iterators that can be used in conjunction with standard algorithm functions, e.g. to copy values to the containers #include <holor/holor_full.h> #include <algorithm> using namespace holor ; Holor < int , 2 > matrix {{ 1 , 2 , 3 }, { 4 , 5 , 6 }}; std :: transform ( matrix . begin (), matrix . end (), matrix . begin (), []( int n ) -> int { return c * 10 ; }); //multiplies all elements in matrix by 10. Matrix now is ((10, 20, 30), (40, 50, 60)) Holor < int , 1 > vec { 111 , 222 }; auto col1 = matrix . col ( 1 ); std :: copy ( vec . begin (), vec . end (), matrix . rbegin ()); //copies vec in reverse on the second column of matrix. Matrix now is ((10, 222, 30), (40, 111, 60))","title":"Iterators"},{"location":"tutorials/layout.html","text":"Layout Basics \u00b6 Construction and assignment of Layouts \u00b6 A layout can be constructed without arguments. In this case its lengths and strides are initalized to zero: #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > my_layout ; std :: cout << \"the dimensions of the layout are \" << my_layout . dimensions () << std :: endl ; // This prints 2 std :: cout << \"the lenghts of the layout are \" << my_layout . length ( 0 ) << \" \" << my_layout . length ( 1 ) << std :: endl ; // This prints 0 0 std :: cout << \"the strides of the layout are \" << my_layout . stride ( 0 ) << \" \" << my_layout . stride ( 1 ) << std :: endl ; // This prints 0 0 std :: cout << \"the size of the layout is \" << my_layout . size () << std :: endl ; // This prints 0 A layout can also be constructed specifying its lengths #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > my_layout1 { 2 , 3 }; Layout < 2 > my_layout2 ( std :: vector < size_t > { 2 , 3 }); Layout < 2 > my_layout3 ( std :: array < int , 2 > { 2 , 3 }); //These three examples of constructor yield the same result std :: cout << \"the dimensions of the layout are \" << my_layout1 . dimensions () << std :: endl ; // This prints 2 std :: cout << \"the lenghts of the layout are \" << my_layout1 . length ( 0 ) << \" \" << my_layout1 . length ( 1 ) << std :: endl ; // This prints 2 3 std :: cout << \"the strides of the layout are \" << my_layout1 . stride ( 0 ) << \" \" << my_layout1 . stride ( 1 ) << std :: endl ; // This prints 3 1 std :: cout << \"the size of the layout is \" << my_layout1 . size () << std :: endl ; // This prints 6 A layout can also be constructed or assigned from another Layout #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 3 > my_layout1 { 2 , 3 , 4 }; Layout < 3 > my_layout2 ( my_layout1 ); Layout < 3 > my_layout3 = my_layout1 ; //my_layout2 and my_layout3 are the same as my_layout1 std :: cout << \"the dimensions of the layout are \" << my_layout2 . dimensions () << std :: endl ; // This prints 3 std :: cout << \"the lenghts of the layout are \" << my_layout2 . length ( 0 ) << \" \" << my_layout2 . length ( 1 ) << \" \" << my_layout2 . length ( 2 ) << std :: endl ; // This prints 2 3 4 std :: cout << \"the strides of the layout are \" << my_layout2 . stride ( 0 ) << \" \" << my_layout2 . stride ( 1 ) << \" \" << my_layout2 . stride ( 1 ) << std :: endl ; // This prints 0 0 0 std :: cout << \"the size of the layout is \" << my_layout2 . size () << std :: endl ; // This prints 6 Resizing a Holor \u00b6 A Layout has a fixed number of dimensions, but the number of elements along each dimension can be changed. This is useful when the number of elements needs to be modified over time, or to create an empty container and resize it later. #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > lay ; //A Layout with 2 dimensions lay . set_lengths ( 3 , 2 ); //Now lay has lengths 3, 2 lay . set_length ( 0 , 2 ); //This operation modifies only the first length and sets it to 2. Now the lengths are 2, 2 Mapping from indices to location in a memory sequence \u00b6 Consider a generic 2D Holor container as represented in figure. Example of mapping between Holor coordinates and memory positions. The element indexed in red is stored in the position 3 of the memory. When slicing (green elements) a new Layout referencing to the same memory is created. The container uses a Layout to map from from its indices to the position in the memory area where the element is stored. The function that implements this mapping is the operator () . #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > lay { 3 , 3 }; //this is the layout of the container represented in figure above. std :: cout << lay . dimensions () << std :: endln ; // lay has 2 dimensions std :: cout << lay . offset () << std :: endln ; // lay has offset 0 std :: cout << lay . size () << std :: endln ; // lay has size 9 std :: cout << lay . length ( 0 ) << \" \" << lay . length ( 1 ) << std :: endln ; // lay has lengths 3, 3 std :: cout << lay . strides ( 0 ) << \" \" << lay . strides ( 1 ) << std :: endln ; // lay has strides 3, 1 auto id = lay ( 0 , 1 ); // indexing: id is a size_t with value 1. auto lay_slice = lay ( range ( 1 , 2 ), range ( 0 , 1 )); // slicing: lay_slice is a new layout that represents the slice with indices ([1, 2], [0, 1]). std :: cout << lay_slice . dimensions () << std :: endln ; // lay_slice has 2 dimensions std :: cout << lay_slice . offset () << std :: endln ; // lay_slice has offset 3 std :: cout << lay_slice . size () << std :: endln ; // lay_slice has size 4 std :: cout << lay_slice . length ( 0 ) << \" \" << lay_slice . length ( 1 ) << std :: endln ; // lay_slice has lengths 2, 2 std :: cout << lay_slice . strides ( 0 ) << \" \" << lay_slice . strides ( 1 ) << std :: endln ; // lay_slice has strides 2, 1","title":"Layout basics"},{"location":"tutorials/layout.html#layout-basics","text":"","title":"Layout Basics"},{"location":"tutorials/layout.html#construction-and-assignment-of-layouts","text":"A layout can be constructed without arguments. In this case its lengths and strides are initalized to zero: #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > my_layout ; std :: cout << \"the dimensions of the layout are \" << my_layout . dimensions () << std :: endl ; // This prints 2 std :: cout << \"the lenghts of the layout are \" << my_layout . length ( 0 ) << \" \" << my_layout . length ( 1 ) << std :: endl ; // This prints 0 0 std :: cout << \"the strides of the layout are \" << my_layout . stride ( 0 ) << \" \" << my_layout . stride ( 1 ) << std :: endl ; // This prints 0 0 std :: cout << \"the size of the layout is \" << my_layout . size () << std :: endl ; // This prints 0 A layout can also be constructed specifying its lengths #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > my_layout1 { 2 , 3 }; Layout < 2 > my_layout2 ( std :: vector < size_t > { 2 , 3 }); Layout < 2 > my_layout3 ( std :: array < int , 2 > { 2 , 3 }); //These three examples of constructor yield the same result std :: cout << \"the dimensions of the layout are \" << my_layout1 . dimensions () << std :: endl ; // This prints 2 std :: cout << \"the lenghts of the layout are \" << my_layout1 . length ( 0 ) << \" \" << my_layout1 . length ( 1 ) << std :: endl ; // This prints 2 3 std :: cout << \"the strides of the layout are \" << my_layout1 . stride ( 0 ) << \" \" << my_layout1 . stride ( 1 ) << std :: endl ; // This prints 3 1 std :: cout << \"the size of the layout is \" << my_layout1 . size () << std :: endl ; // This prints 6 A layout can also be constructed or assigned from another Layout #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 3 > my_layout1 { 2 , 3 , 4 }; Layout < 3 > my_layout2 ( my_layout1 ); Layout < 3 > my_layout3 = my_layout1 ; //my_layout2 and my_layout3 are the same as my_layout1 std :: cout << \"the dimensions of the layout are \" << my_layout2 . dimensions () << std :: endl ; // This prints 3 std :: cout << \"the lenghts of the layout are \" << my_layout2 . length ( 0 ) << \" \" << my_layout2 . length ( 1 ) << \" \" << my_layout2 . length ( 2 ) << std :: endl ; // This prints 2 3 4 std :: cout << \"the strides of the layout are \" << my_layout2 . stride ( 0 ) << \" \" << my_layout2 . stride ( 1 ) << \" \" << my_layout2 . stride ( 1 ) << std :: endl ; // This prints 0 0 0 std :: cout << \"the size of the layout is \" << my_layout2 . size () << std :: endl ; // This prints 6","title":"Construction and assignment of Layouts"},{"location":"tutorials/layout.html#resizing-a-holor","text":"A Layout has a fixed number of dimensions, but the number of elements along each dimension can be changed. This is useful when the number of elements needs to be modified over time, or to create an empty container and resize it later. #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > lay ; //A Layout with 2 dimensions lay . set_lengths ( 3 , 2 ); //Now lay has lengths 3, 2 lay . set_length ( 0 , 2 ); //This operation modifies only the first length and sets it to 2. Now the lengths are 2, 2","title":"Resizing a Holor"},{"location":"tutorials/layout.html#mapping-from-indices-to-location-in-a-memory-sequence","text":"Consider a generic 2D Holor container as represented in figure. Example of mapping between Holor coordinates and memory positions. The element indexed in red is stored in the position 3 of the memory. When slicing (green elements) a new Layout referencing to the same memory is created. The container uses a Layout to map from from its indices to the position in the memory area where the element is stored. The function that implements this mapping is the operator () . #include <Holor/holor/holor_full.h> using namespace holor ; Layout < 2 > lay { 3 , 3 }; //this is the layout of the container represented in figure above. std :: cout << lay . dimensions () << std :: endln ; // lay has 2 dimensions std :: cout << lay . offset () << std :: endln ; // lay has offset 0 std :: cout << lay . size () << std :: endln ; // lay has size 9 std :: cout << lay . length ( 0 ) << \" \" << lay . length ( 1 ) << std :: endln ; // lay has lengths 3, 3 std :: cout << lay . strides ( 0 ) << \" \" << lay . strides ( 1 ) << std :: endln ; // lay has strides 3, 1 auto id = lay ( 0 , 1 ); // indexing: id is a size_t with value 1. auto lay_slice = lay ( range ( 1 , 2 ), range ( 0 , 1 )); // slicing: lay_slice is a new layout that represents the slice with indices ([1, 2], [0, 1]). std :: cout << lay_slice . dimensions () << std :: endln ; // lay_slice has 2 dimensions std :: cout << lay_slice . offset () << std :: endln ; // lay_slice has offset 3 std :: cout << lay_slice . size () << std :: endln ; // lay_slice has size 4 std :: cout << lay_slice . length ( 0 ) << \" \" << lay_slice . length ( 1 ) << std :: endln ; // lay_slice has lengths 2, 2 std :: cout << lay_slice . strides ( 0 ) << \" \" << lay_slice . strides ( 1 ) << std :: endln ; // lay_slice has strides 2, 1","title":"Mapping from indices to location in a memory sequence"}]}