layout.h:
    ☐ //IMPROVEMENT: When slicing a Layout in slice_dimension, each step of the recursion returns a subLayout. This seems inefficient. Is it possible to avoid the creation of all these intermediate objects, perhaps using Coroutines? Additionally, the slicing of the arrays of lengths and strides that are inside the Layout to be sliced could be done with ranges, which support lazy evaluation.
    ☐ //TODO: use a proper LayoutType concept (Line 64)

indexes.h:
    ☐ //TODO: So far the step in range is not supported 
    ☐ //TODO: generalize to allow also ranges in decreasing order, e.g., start = 5, end = 1, step = -2

holor_ref.h:
    ☐ //TODO: use a proper concept for HolorContainer (Line 498)

holor_printer.h:
    ☐ verify and clean up the print function
    ☐ //TODO: use a proper concept for HolorType (Line )

concepts.h:
    ☐ Concept HolorType
    ☐ Concept LayoutType

static_assert.h:
    ☐ //TODO: reorder this file, common_concepts and common_predicates.

Archive:
  ✔ implement concept Printable @done(21-07-14 15:31) @project(holor_printer.h)
  ✔ Add function to HolorRef elements from an Holor or HolorRef with suitable dimensions and lengths. Essentially, this function should wrap a dimensionality check plus a call to std::copy (or move in the case of a Holor rvalue) @done(21-07-14 14:22) @project(holor_ref.h)
  ✔ //NOTE: check includes @done(21-07-14 13:02) @project(holor_ref.h)
  ✔ holor.h: @done(21-07-14 11:54)
  ✔ //NOTE: check includes @done(21-07-14 11:54)
  ✔ Finish implementing constructors and assignment operators @done(21-07-14 11:32) @project(holor.h)
  ✔ initializer.h: @done(21-07-14 11:31)
  ✔ Now the slicing function reduces the dimension of the Layout (and thus of the holor container). It could be useful to have also a version that retains the dimensions of the Layout (and thus of container,  so that for example a slicing a column from a matrix has lenghts [1, c] rather than [c]) @done(21-07-13 22:44) @project(layout.h)
  ✘ //TODO: improve description, perhaps with images @cancelled(21-07-13 16:55) @project(layout.h)
  ✔ //TODO: add specialization of element indexing for a Layout<4> (used in four-dimensional tensors) @done(21-07-13 15:17) @project(layout.h)
  ✔ //NOTE: check includes @done(21-07-13 15:17) @project(layout.h)
  ✘ //TODO: Layout concept (refer to https://andreasfertig.blog/2020/08/cpp20-concepts-testing-constrained-functions/ for info on constrained variadic function templates). This was cancelled because it is not possible to verify that a type can be indexed with a variadic template of arguments without passing the template arguments to the check, i.e., without specializing the layout. Namely, it is not possible to have a template<typename T> concept Layout, but it should be template<typename T, typename... Args> concept Layout. @cancelled(21-07-13 14:01) @project(layout.h)
  ✔ //TODO: change dependencies in layout.h to use this header, and in layout.h add dynamic_checks on indexes (those that cannot be done in indexes.h) @done(21-07-12 20:00) @project(indexes.h)
  ✔ Templatize `dim`: Right now, the recursive slicing operation on a layout (slice_dimension, slice_helper) take a size_t dim as an argument. Conceptually, it would make sense to have it as a template parameter, to separate the indexing argument from the dimension. Moreover, in slice_helper `dim` is used to unwind the recursive calls to the function, therefore it would be better set as a template parameter. Using a template parameter would also make it possible to translate all the checks on dim as compile time requiurements, rather than dynamic assertions. The problem is that simply changing it to a template parameter makes slice_helper not compile anymore @done(21-04-30 11:18) @project(layout.h)
